
import * as React from 'react'


import { ICRIFromMongo } from './commonAll'
import { CVMode, CVModeTransformers, getCRKindChain, makeDivSizeStyle, SizeProps, SizePropsPx } from './commonApp'
import { TI, TIG, TII, TIInfo2 } from '../ttable/table items base'
import CodeMirrorView from './codemirrorView';
import { CR, CRG, CRI } from '../ttable/table items CR';
import { TTableCR } from '../ttable/TTableCR';
import { HARInitiator } from './harFormatExtended'
import { InitView } from '../ttable/Pres InitView';

var _ = require('lodash');

const cl = console.log;


/*
  revision plan
    
    need to provide for three cases of group prop handling
      group prop always undefined
      group prop returned only if there is one unique value, otherwise '<multiple>'
      group prop returns multiple unique values

    adhere to:
      stored prop values will have no accommodations for display
      

why are we storing object versions in addition to string versions anyway?
  could just store the object, and compute string on-demand, however...
  1) pre-computed string version so that tests do not force re-computation every time they apply
  1.5) pre-compute string version before storage in mongo, so that (at some point) we can filter mongo queries based on the values of the strings
  2) want to keep object version as well, so that ContentView can show TTableObj
  so far, string version of an object is just the JSON.stringified object
    EXCEPT for headers, where we create a special string representation

restate basic rules
  plain propvalue must be
    1-1 consistent with source
    plain string, so can be tested - do not overload with adorning for display
    if source was not a primitive, serve will also store propnameObject, which is a copy of the source

new grouped prop approach
  restating the previous needs:
    1) want the values stored in the TI to be plain strings, so that search/filtering is easy
    2) need to be able to always distinguish between a single value and multiple values
    3) need to always retain the 'source' data intact - in case the string-ified representaion 
        cannot (or at least not easily) be translated back into the source version
        - for sources that are strings (which is usually the case), this just happens automatically
        - for sources that are objects, sometimes we JSON.stringify the object,
          but sometimes (e.g., headers) we create a formatted string representation
    4) to aggregate strings, could concatenate with a delimiter, and then 
        disaggregate with .split, however, there is no one delimiter that will work 
        across all source props - some might contain ',' while others might contain '\n'
        and, potentially, some source props might contain any unicode character

  however,
    the previous approach requires one of two hassles for singleton values
    because we need to detect whether a stored value is a singleton or collection,
    we need to either
      a) store the singleton as a JSON.stringified array, which is a pain when
          creating them and working with them in TII's where we know they are singletons anyway
      or b) store the singleton as a primitive string and 
            every time we use one, either test if the container is a TII or TIG,
            or try JSON.parse and catch if it fails
  
  revised approach to grouping props
    (reasons for revising previous approach:
      still need prop values to be strings so tests/filters work
      avoids need to JSON-ify the child prop values when they may contain delimiters
      allows us to attach metadata (e.g., color) to prop values without having to embed the metadata in the prop value string itself
    )
    for every grouped prop, there will be a companion prop named propName+'PropItems'
    the grouped prop value itself will be the child props .join('\n')
    the PropItems will be
      items: flat array of leaves, i.e., the ultimate CRI items (deduped or not, depending on method)
      count, uniqueCount:  number of leaf items - one of these will be redundant with items.length, but we will compute and store them for convenience
    each item in PropItems will be
      the source item value
      copy of the source object (if there was one)
      color: color code for display
      possibly other metadata we may add in future
    for CRI, PropItems needs to be 
      constructed in convertOnLoad for props from server
      computed in CRI for computed props
    for CRG, PropItems will be generated by computeGroupProp

    

  (previous) new approach
  // OBSOLETE   now have two types of grouped props
  // OBSOLETE     genericGroupedAsArray 
  // OBSOLETE       use JSON.stringified array for all values (single and multiple, in TII and TIG)
  // OBSOLETE       manage backing source object alongside
  // OBSOLETE     genericStringsGroupedAsList
  // OBSOLETE       use '\n' delimiter for multiple values)
  // OBSOLETE         (maybe in future would add other delimiters if needed)
  // OBSOLETE       do not need to manage backing objects
  // OBSOLETE   create a new propMethod for props where we can use '\n' as a delimiter
  // OBSOLETE     which should work for most props, actually
  // OBSOLETE   also, allow a TII to have multiple values (want this for PHIs, where a single
  // OBSOLETE     PHI might have multiple items for, say, requestor)
  // OBSOLETE   also, revise the aggregation approach to simply collect all the values from 
  // OBSOLETE     children, without reducing to the set of uniques
  // OBSOLETE     -> reducing to unique values will happen in the [single|multi]line[String\JSX] methods
  // OBSOLETE   also, change display when multiple values to show both total number of values
  // OBSOLETE     and number of uniques



*/



// template for all TI prop function sets
export interface TIPropFunctions {
  hasPropItems: boolean
  // conversion to apply on loading from mongo into TTable
  // modifies cr in-place, does not return a new value
  convertOnLoad(cr: {[index: string]: any}, propName: string ): void
  // NOTE: CHILDREN PASSED AS ARGUMENT SO THAT MOBX WILL DETECT DEPENDENCY ON TIG CHILDREN
  // tig is also passed as an argument - can get the tig from the childrens' parentTI property, but this is a hassle
  testMethod(propValue: string, trueIfEqual: boolean, regex: RegExp, ifChildTIIResultsDisagree: boolean): boolean
  val(ti: TI, propName: string): number  // returns validation result (used in TTableConfig)
                    // result is number - the only universal value is 0 for 'valid', other values are specific to table types
  active(ti: TI, propName: string): boolean   // returns whether prop is 'active' (so should not be grayed out) (used for TTableConfig)
  computeGroupProp(tig: TIG, children: TI[], propName: string) : string | number | undefined 
  // function to compute object-valued group prop (only needed for properties where we maintain the backing source object as a separate prop)
  singleLineString(propName: string, ti: TI): string
  // returns array of (string | JSX.Element) - these will be wrapped in a div and styled by the caller
  singleLineJSX(propName: string, ti: TI, rowIndex: number, colIndex: number): JSX.Element | string
  multiLineString(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): string
  contentViewJSX   (ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): JSX.Element
}
export interface TIPropFunctionMap { [index: string]: TIPropFunctions }










// for props where the CRG value is not a function of the children (e.g., kind)
export const generic : TIPropFunctions = {
  hasPropItems: false,
  // conversion to apply on loading from mongo into TTable
  convertOnLoad(cr: {[index: string]: any}, propName: string): void { return },
  testMethod(propValue: string, trueIfEqual: boolean, regex: RegExp, ifChildTIIResultsDisagree: boolean): boolean { 
    return (trueIfEqual) === (regex.test(propValue)) 
  },
  val(ti: TI, propName: string): number { return 0 },
  active(ti: TI, propName: string): boolean { return true },
  computeGroupProp(tig: TIG, children: TI[], propName: string) : string | number | undefined {
    if (children.length === 0) return undefined
    else return tig[propName]
  },
  singleLineString(propName: string, ti: TI): string {
      if (ti[propName] === undefined) return '---'
      else return ti[propName].toString()
  },
  singleLineJSX(propName: string, ti: TI): JSX.Element | string {
    return generic.singleLineString(propName, ti).toString()
  },
  multiLineString(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): string {
    if (ti[propName] === undefined) return ''
    else return CVModeTransformers[cvMode](ti[propName])
  },
  contentViewJSX(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): JSX.Element {
    if (ti[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
    else return <div className='ttCellMultiLineJSX'>{CVModeTransformers[cvMode](ti[propName])}</div>
  },

}



export interface PropItems {
  count: number
  uniqueCount: number
  criItems: PropItemsCRIItem[]
}


export interface PropItemsCRIItem {
  color: number
  item: string     // the original value of cr[propName] from server
  object?: Object  // the backing object from server, if it exists
}


export interface PropItemsHeaders extends PropItems {
  criItems: PropItemsCRIItemHeader[]
}

export interface PropItemsCRIItemHeader extends PropItemsCRIItem {
  modifiedCount: number
  object: HeaderWithType[]   // non-optional - will always exist for header props
}


export interface QueryParam {
  name: string
  value: string
}

export interface PropItemsQueryParams extends PropItems {
  criItems: PropItemsCRIItemQueryParam[]
}

export interface PropItemsCRIItemQueryParam extends PropItemsCRIItem {
  modifiedCount: number
  object: QueryParam[]   // non-optional - will always exist for header props
}



export const genericGroupedKeepDups : TIPropFunctions = {
  hasPropItems: true,
  convertOnLoad(cr: {[index: string]: any}, propName: string) {
    generic.convertOnLoad(cr, propName)
    // create PropItems
    const propItems: PropItems = {
      count: 1,
      uniqueCount: 1,
      criItems: (cr[propName] !== undefined) ? [
        {
          color: cr[propName] === 'POST' ? 1 : 0,
          item: cr[propName] 
        }
      ] : []
    }
    if (cr[propName+'Object'] !== undefined) {
      propItems.criItems[0].object = cr[propName+'Object']
      delete cr[propName+'Object']
    }
    cr[propName+'PropItems'] = propItems
  },
  testMethod: generic.testMethod,  // NOTE - had been using generigGroupedAsListKeepDups.val (code below) - not sure if necessary
  // OBSOLETE   testMethod(propValue: string, trueIfEqual: boolean, regex: RegExp, ifChildTIITestResultsDisagree: boolean): boolean {
// OBSOLETE     const counts = getUniquesAndCountsForGenericGroupedAsListKeepDups(propValue)
// OBSOLETE     const items = Object.getOwnPropertyNames(counts.counts).sort()   // we sort here, but not for multiLineString, because ContentView has a 'sorted' mode
// OBSOLETE 
// OBSOLETE     // logic here is same as in TestOrGroup.result for testing over child TIs
// OBSOLETE     let anyTrue: boolean = false
// OBSOLETE     let allTrue: boolean = true
// OBSOLETE     for (let i of items) {
// OBSOLETE       if (trueIfEqual === regex.test(i)) anyTrue = true
// OBSOLETE       else allTrue = false
// OBSOLETE     }
// OBSOLETE     if (allTrue) return true
// OBSOLETE     else if (anyTrue) return ifChildTIITestResultsDisagree
// OBSOLETE     else return false
// OBSOLETE   },
  val: generic.val,
  active: generic.active,
  computeGroupProp(tig: TIG, children: TI[], propName: string) {

    //cl(`genericGroupedKeepDups computeGroupProp called`)

    const resultPropItems: PropItems = {
      count: 0,
      uniqueCount: 0,
      criItems: []
    }
    for (let c of children) {
      // c[propName] may be undefined for one of two reasons:
      // c is a group and c[propName] has not been accessed yet, in which case c[propName+'PropItems'] will not exist - call computeGroupProp to generate it
      // c is not a group and c[propName] is undefined for this TII
      // note: we reference c[propName] here, not c[propName+'PropItems'], so that mobx will make this function an observer of c[propName] and react when a child changes (e.g., if headersToShow changes)
      if ((c[propName] === undefined) && (c.group === 'yes')) genericGroupedKeepDups.computeGroupProp(c as TIG, c.children, propName)
      if ((c instanceof TII) && (c.testResults.hide === true)) continue  // don't include child TIIs that are hidden
      if (c[propName+'PropItems'] !== undefined) resultPropItems.criItems.push(...c[propName+'PropItems'].criItems)
    }
    const counts = _.countBy(resultPropItems.criItems, 'item')
    resultPropItems.count = resultPropItems.criItems.length
    resultPropItems.uniqueCount = Object.getOwnPropertyNames(counts).length
    tig[propName+'PropItems'] = resultPropItems

    const result = resultPropItems.criItems.map(i => i.item).join(' \u2B2A ')

    return result
  },
  singleLineString(propName: string, cr: CR): string {
    if (cr[propName] === undefined) return '---'
    else return cr[propName]
  },
  singleLineJSX(propName: string, cr: CR): JSX.Element | string {
    if (cr[propName] === undefined) return '---'
    if (cr.group === 'yes') {
      // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
      // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
      if (cr[propName+'PropItems'] === undefined) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
      //   compute max color value
      //   return span with color
      const is: PropItems = cr[propName+'PropItems']
      const maxColor = is.criItems.reduce((prev, curr) => Math.max(prev, curr.color), 0)
      return <span key='s' style = { { color: infoCellTextColors[maxColor] } }>{`${(is.criItems.length > 1) ? `(${is.count}/${is.uniqueCount}u) ` : ''}${is.criItems.map(i => i.item).join(' \u2B2A ')}`}</span>
    }
    else {
      const r: PropItemsCRIItem = cr[propName+'PropItems'].criItems[0]
      return <span key='s' style = { { color: infoCellTextColors[r.color] } }>{r.item}</span>
    }
  },
  multiLineString(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode): string {
    if (cr[propName] === undefined) return ''
    // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
    // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
    if ((cr[propName+'PropItems'] === undefined) && (cr.group === 'yes')) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
    const is: PropItems = cr[propName+'PropItems']
    const items = is.criItems.map((i: PropItemsCRIItem) => i)
    if ((cvMode === 'sorted') || (cvMode === 'sortedUrl')) {
      items.sort((a,b) => { if (a.item < b.item) {return -1} else if (a.item === b.item) {return 0} else {return 1}})
    } 
    var result: string = ''
    if (includeCount && (is.count > 1)) {
      result += `(${is.count} total items, ${is.uniqueCount} unique)\n===============\n`
    }
    for (let i of items) {
      result += `${CVModeTransformers[cvMode](i.item)}\n`
      // for object-backed props, the strings are likely to be multiline themselves, so put a divider between items
      if (cr[propName+'ObjectItems'] !== undefined) result += '=========================\n'
    }
    return result.slice(0, -1) // remove trailing '\n'

  },
  contentViewJSX(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode, size?: SizePropsPx): JSX.Element {
    if (cr[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
    // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
    // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
    if ((cr[propName+'PropItems'] === undefined) && (cr.group === 'yes')) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
    const is: PropItems = cr[propName+'PropItems']

    return (
      <CodeMirrorView
        value={genericGroupedKeepDups.multiLineString(cr, propName, includeCount, cvMode)}
        mode={cvMode}
        // OBSOLETE initialFocus={'matchInput'}
        // OBSOLETE initialMatchPattern=''
        size={ size }
        editable={false}
      />
    )
  },
}



export const genericGroupedDeduped : TIPropFunctions = {
  hasPropItems: true,
  convertOnLoad: genericGroupedKeepDups.convertOnLoad,
  testMethod: genericGroupedKeepDups.testMethod,
  val: genericGroupedKeepDups.val,
  active: genericGroupedKeepDups.active,
  computeGroupProp(tig: TIG, children: TI[], propName: string) {

    //cl(`genericGroupedDeduped computeGroupProp called`)

    const resultPropItems: PropItems = {
      count: 0,
      uniqueCount: 0,
      criItems: []
    }
    const itemMap: Map<string, PropItemsCRIItem> = new Map()
    for (let c of children) {
      // c[propName] may be undefined for one of two reasons:
      // c is a group and c[propName] has not been accessed yet, in which case c[propName+'PropItems'] will not exist - call computeGroupProp to generate it
      // c is not a group and c[propName] is undefined for this TII
      if ((c[propName] === undefined) && (c.group === 'yes')) genericGroupedDeduped.computeGroupProp(c as TIG, c.children, propName)
      if ((c instanceof TII) && (c.testResults.hide === true)) continue  // don't include child TIIs that are hidden
      const cItems: PropItems = c[propName+'PropItems']
      if (cItems !== undefined) {
        resultPropItems.count += cItems.count
        for (let i of cItems.criItems) {
          if (itemMap.get(i.item) === undefined) itemMap.set(i.item, i)
        }
      }
    }
    resultPropItems.uniqueCount = itemMap.size
    resultPropItems.criItems = Array.from(itemMap.values())
    tig[propName+'PropItems'] = resultPropItems

    const result = resultPropItems.criItems.map(i => i.item).join(' \u2B2A ')



    // generate associated ObjectItems


    return result
  },
  singleLineString: genericGroupedKeepDups.singleLineString,
  singleLineJSX:    genericGroupedKeepDups.singleLineJSX,
  multiLineString:  genericGroupedKeepDups.multiLineString,
  contentViewJSX:   genericGroupedKeepDups.contentViewJSX,
}

export const initiator : TIPropFunctions = {
  hasPropItems: true,
  convertOnLoad: genericGroupedKeepDups.convertOnLoad,
  testMethod: genericGroupedKeepDups.testMethod,
  val: genericGroupedKeepDups.val,
  active: genericGroupedKeepDups.active,
  computeGroupProp: genericGroupedKeepDups.computeGroupProp,
  singleLineString: genericGroupedKeepDups.singleLineString,
  singleLineJSX:    genericGroupedKeepDups.singleLineJSX,
  multiLineString:  genericGroupedKeepDups.multiLineString,
  contentViewJSX(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode, size?: SizePropsPx): JSX.Element {
    if (cr[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
    // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
    // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
    if ((cr[propName+'PropItems'] === undefined) && (cr.group === 'yes')) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)

    //cl(`======================`)
    //cl(`initiator contentViewJSX callled with size: ${JSON.stringify(size)}`)

    return <InitView cr={cr} cvMode={cvMode} size={size}/>

  },
}





export type HeaderOperationName = 'set' | 'append' | 'remove'
export type HeaderOperationOutcomeName = HeaderOperationName | 'none'


export type HeaderType =  'original  '    // as present in pre-modification event
                        | 'added     '    // present post-modification but not pre-mod
                        | 'notInFinal'    // present pre-modification but not post-mod
                  // OBSOLETE       | 'changed   ' - no way to distinguish between a case where header name X was changed, vs header name X was removed, then header name X was added
                        | 'asoriginal'    // present (with identical name and value) in pre- and post-mod
                        | 'final     '    // as present in post-modification (and we didn't have the pre-mod event, so we don't know whether it is asoriginal or added)
// see headersPropMethods.computeGroupProp for details on how populated



// chrome.webRequest.HttpHeader has name, value?, binaryValue?
// and will have one of value or binaryValue
// propMethods-server will have created a value prop if the source event provided a binaryValue
export interface HeaderWithType {
  type: HeaderType
  displayColor: number
  name: string
  value: string
}


export interface HeaderOperation {
  displayColor: number
  operation: HeaderOperationName
  name: string
  value: string | undefined
}

/* OBSOLETE? WILL WE NEED THIS?  OUTCOME MAY JUST BECOME PART OF HEADERS PROP DISPLAY
export interface HeaderOperationOutcome {
  displayColor: number
  operation: HeaderOperationOutcomeName
  name: string
  valueBefore: string
  value: string
}
*/


function headerPropItemsToShow(cr: CR, all: PropItemsHeaders): PropItemsHeaders {
  const headersToShowResult: HeaderWithType[] = []
  const headerTypesToShow = (cr.parentTTable as TTableCR).headerTypesToShow
  const headerNamesToShow = (cr.parentTTable as TTableCR).headerNamesToShow
  const showNameRegex = (cr.parentTTable as TTableCR).headersToShowNameRegex
  const showValueRegex = (cr.parentTTable as TTableCR).headersToShowValueRegex
  const hideNameRegex = (cr.parentTTable as TTableCR).headersToHideNameRegex
  const hideValueRegex = (cr.parentTTable as TTableCR).headersToHideValueRegex
  for (let h of all.criItems[0].object) {
    // if type to show false, do not show
    // else if matches show nameRegex, show
    // else if matches show valueRegex, show
    // else if matches hide nameRegex, do not show
    // else if matches hide valueRegex, do not show
    // else if name not in headerNamesToShow, show if _other
    // else show if headerNamestoShow true
    // else do not show
    if (headerTypesToShow[h.type] === false) continue 
    if (showNameRegex !== undefined) if (showNameRegex.test(h.name) === true) { headersToShowResult.push(h); continue }
    if (showValueRegex !== undefined) if (showValueRegex.test(h.value) === true) { headersToShowResult.push(h); continue }
    if (hideNameRegex !== undefined) if (hideNameRegex.test(h.name) === true) continue
    if (hideValueRegex !== undefined) if (hideValueRegex.test(h.value) === true) continue
    if ((headerNamesToShow[h.name] === undefined) && (headerNamesToShow['__other'] === true)) { headersToShowResult.push(h); continue }
    if (headerNamesToShow[h.name] === true) headersToShowResult.push(h)
  }
  const resultString = headersToShowResult.map(h => h.name + ': ' + h.value).join(' \u2B2A ')
  return {
    uniqueCount: 1,
    count: 1,
    criItems: [{
      color: 0,
      modifiedCount: 0,
      item: resultString,
      object: headersToShowResult
    }]
  }
}

// uses genericGroupedDeduped, except
//     assigns headerType prop in convertOnLoad, for CRI's
//     computes headerType for CRGs
//     creates specialized displays
//     uses CodemirrorView for contentViewJSX
export const headersPropMethods : TIPropFunctions = {
  hasPropItems: true,
  convertOnLoad(cr: {[index: string]: any}, propName: string) {
    genericGroupedDeduped.convertOnLoad(cr, propName)

    // set 'modifiedCount' prop
    cr[propName+'PropItems'].criItems[0].modifiedCount = 0
    const all: HeaderWithType[] = cr[propName+'PropItems'].criItems[0].object

    // add 'type' prop to each header in object
    // set it to 'final' - this will be appropriate for any harI and any post-modification webReqI
    var headerType: HeaderType = 'final     '
    // if event is a pre-modification event, set to 'original  '
    switch (cr.event) {
      case 'wrOnBeforeSendHeaders':
      case 'wrOnHeadersReceived':
        headerType = 'original  '
        break
      default:
        break
    }
    for (let h of all) {
      h.type = headerType
      h.name = h.name.toLowerCase()
    }
    // sort headers by name, value
    all.sort((a, b) => { 
      if (a.name < b.name) return -1
      else if (a.name > b.name) return 1
      else if (a.value < b.value) return -1
      else return 1
    })
    cr[propName+'PropItems'].criItems[0].object = all
    cr[propName+'PropItems'].criItems[0].item = all.map(h => `${h.name}: ${h.value}`).join('\n')
    cr[propName] = cr[propName+'PropItems'].criItems[0].item

  },
  testMethod: genericGroupedDeduped.testMethod,
  val: genericGroupedDeduped.val,
  active: genericGroupedDeduped.active,
  computeGroupProp(crg: CRG, children: CR[], propName: string) {
    const all: HeaderWithType[] = []

    // if not a urlG or webReqG, just call genericGroupedDeduped.computeGroupProp
    if (crg.kind === 'webReqG') {
      // consolidate headers from children, update header types
      // unlike generic computeGroupedProp, this will produce a PropItems with a single item,
      // the consolidated list of headers for the group
      // with the header types changed to 'asoriginal', 'changed', etc.
      //
      // note that, per spec, pre-mod headers are only on 
      //      request: pre: 'onBeforeSendHeaders'   post: 'onSendHeaders'
      //      response:  pre: 'onHeadersReceived'  post: 'onBeforeRedirect' OR ( 'onResponseStarted' AND 'onCompleted' ) (see webRequest spec)
      //        

      // so
      //    for request, we will have at most one copy of the pre mod headers, and at most one copy of the post mod headers
      //    for response, will have at most one copy of pre mod headers, but could have two copies of post mod headers
      //      if there is an onResponseStarted and onCompleted event - in this case just ignore the onResponseStarted

      // also note that the same header name can appear more than once in the same request or response
      // thus, if the same name and value is present in the pre- and post-mod events, there is no way to tell
      // if that is because the original one was modified, or the original was deleted, then added back with the same value

      // how header types will be populated
      // three scenarios:
      //    we have only the pre-modification webRequest event
      //      ==> all headers will be typed as 'original' (this is done in convertOnLoad)
      //    we have only the post-modification event
      //      ==> all headers will be typed as 'final' (this is done in convertOnLoad)
      //    we have both the pre- and post-modification events
      //      ==> compare the pre- and post-mod header lists
      //            for each unique name: value combination
      //                if present in both, drop the duplicate and type it 'asoriginal'
      //                if only present pre-mod, type it as 'removed'
      //                if only present post-mod, type it as 'added'

      var pre: CR | undefined
      var post: CR | undefined
      // get pre- and post- events
      if (propName === 'reqHeaders') {
        pre = children.find(cri => (cri.event === 'wrOnBeforeSendHeaders'))
        post = children.find(cri => (cri.event === 'wrOnSendHeaders'))
      }
      else {
        pre = children.find(cri => (cri.event === 'wrOnHeadersReceived'))
        // find the onCompleted - if there is none, look for onResponseStarted, if that is not present either, look for onResponseStarted
        post = children.find(cri => (cri.event === 'wrOnCompleted'))
        if (post === undefined) post = children.find(cri => (cri.event === 'wrOnResponseStarted'))
        if (post === undefined) post = children.find(cri => (cri.event === 'wrOnBeforeRedirect'))

        // COULD HAVE BOTH onResponseStarted AND onCompleted - IF THERE IS NO PRE, THIS WILL NOT CONSLIDATE THE HEADERS INTO A SINGLE OBJECT
        // MAYBE WE WANT TO DO THAT - IMPLEMENT IF IT BECOMES AN ISSUE

      }
      // assemble consolidated list of headers
      // make array with copies of all pre and post headers, sorted by name and putting original before final
      // NOTE: uses cloneDeep so that we are not modifying the headers in the source CRs
      if (pre !== undefined)  all.push(... _.cloneDeep(pre[propName+'PropItems'].criItems[0].object))
      if (post !== undefined) all.push(... _.cloneDeep(post[propName+'PropItems'].criItems[0].object))

      // sort by name, value, type (original before final)
      all.sort((a, b) => { 
        if (a.name < b.name) return -1
        else if (a.name > b.name) return 1
        else if (a.value < b.value) return -1
        else if (a.value > b.value) return 1
        else if (a.type === 'original  ') return -1
        else return 1
      })

      // only do deduping if we have both pre and post, otherwise fall through to finalize the prop and propItems
      if ((post !== undefined) && (pre !== undefined)) {
        // iterate over array, handling duplicate names and unique names
        // (we know we have both pre and post events, because would have returned above if not)
        for (let index = 0; index < all.length; ) {
          // if we have an original and a final with the same name and value
          if ((index+1 < all.length) && (all[index].name === all[index+1].name) && (all[index].type==='original  ') && (all[index+1].type==='final     ')) {
            if (all[index].value === all[index+1].value) {
              // change type to 'asoriginal' and remove duplicate
              all[index+1].type = 'asoriginal'
              all.splice(index, 1)
              index++
            }
            else {
              // change type of original to removed and final to added
              all[index].type   = 'notInFinal'
              all[index+1].type = 'added     '
              index += 2
            }
          }
          // else if we have an original but no final (and we do have a post event), change type to removed
          else if (all[index].type === 'original  ') { all[index].type = 'notInFinal'; index++ }
          // else it was added
          else                                       { all[index].type = 'added     '; index++ }

        }

      }

  

    } 
    else {  // higher level groups
      // build array of all headers on children
      for (let c of crg.children) {
        // generate the child's prop if has not be generated yet
        if ((c[propName] === undefined) && (c instanceof TIG)) headersPropMethods.computeGroupProp(c, c.children, propName)
        if ((c instanceof TII) && (c.testResults.hide === true)) continue  // don't include child TIIs that are hidden
        if (c[propName] !== undefined) all.push(...c[propName+'PropItems'].criItems[0].object)
      }
      // sort by name, value, type
      all.sort((a, b) => { 
        if (a.name < b.name) return -1
        else if (a.name > b.name) return 1
        else if (a.value < b.value) return -1
        else if (a.value > b.value) return 1
        // else sort into deterministic order by type, to support the consolidation below
        else if (a.type === 'final     ') return 1  // place final last
        else if ((a.type === 'asoriginal')&&(b.type !== 'final     ')) return 1  // place asoriginal next to last
        else if ((a.type === 'asoriginal')&&(b.type === 'final     ')) return -1  // place asoriginal next to last
        else if (a.type === 'original  ') return -1  // place original first
        else return 1
      })

      const resultForDebuggingBeforeConsolidation = all.map(h => h.type + ' - ' + h.name + ': ' + h.value)

      if (crg.kind === 'urlG') {
    
        // just take union of all headers in the urlG
        // similar to webReqG, but consolidating the webReqG with any harI
        // ALSO, remove any of the harI 'headers' that are not really http headers, e.g., ':method: GET' - har prefixes the name with :
  
        // what if there are multiple webReqGs and/or harI's in the urlG?
        //   can happen if page reloaded, for example
        //   presumably headers will all be the same for the most part
        //   and there would be cases where the header names are all the same but values differ
        //   would want to see cases where they differ
        //   would want to see union of all the unique headers in the urlG
  
        // harI headers are all final, but reconcile them with final headers from webReqG
        // they should all match (at least for post-modification headers), but i do see exceptions (see below)
        //
        // don't worry about associating specific harIs with specific webReqGs
        // and don't worry about multiple webReqGs - just take the union
        //    eliminate duplicates (name and value matching)
        //    if we had both pre and post events, webReqG headers will never be 'final' or 'original'
        //      so match the harI headers with the 'added'|'asoriginal' webReqG header
        //    else the webRegG headers will be 'original' or 'final', in which case 
        //      if wRG header is 'final', just merge them
        //      if the wRG header is 'original' then keep both (don't merge)
        //
        // other patterns observed:
        //
        //     request succeeds, but onCompleted has no response headers (don't know why this happens)
        //       if have a harI, use that
        //
        //     request succeeds, but wrOnCompleted only has some of the response headers
        //       NOT SURE IF THIS HAPPENS, HAVEN'T OBSERVED A CASE OF IT
        //
        //     request succeeds, but some headers were modified
        //       we have seen several cases (not sure what causes one vs. the others):
        //       case 1: harI reflects the mods
        //       case 2: harI does NOT reflect the mods
        //       case 3: wrOnCompleted does not have any response headers
        //
        //     request fails due to my blocking
        //       wrOnErrorOccurred and harI will have no response headers (because request was never made)
        //
        //     request fails for other reason
        //       final wr event is wrOnCompleted, but harI has error = net::ERR_ABORTED
        //         wrOnCompleted has response headers
        //       final wr event will be wrOnErrorOccurred
        //
        //
        //     remember that there are (at least) two basic purposes for header examination
        //       debugging my dNR implementation
        //       checking that my dNR header mod rules are having intended effect
        //           will be drilling down to individual wr/har events to examine this
        //       scanning all headers that are coming through for 'interesting' ones
        //           main concern is that higher level group props include all headers we see
        //           so only delete them if truly duplicates
        //           live with sometimes seeing a header as 'original' when it was actually final but, say, my wrOnCompleted didn't have it
        //
        //   ==> overall answer (at least for now) is to just take union of all headers observed in events
        //   only remove duplicates when 
        //     name, value, type all match
        //     name, value match, and one is 'final' and other is 'asoriginal' or 'added' - remove dup call it asoriginal|added

    
  
        for (let index = 0; index < all.length - 1;) {   // note - we advance index manually, or not, inside loop, depending on conditions
          // compare index with index+1, consolidate as appropriate
          const i0 = all[index]
          const i1 = all[index+1]

          // if this is a har 'meta-header' (name prefixed with :), just drop it
          if (i0.name.slice(0, 1) === ':') {
            all.splice(index, 1)
            // do not advance index in this case
          }
          
          // if name and value match, handle the duplicate
          else if ((i0.name === i1.name) && (i0.value === i1.value)) {
            // see notes above for how we handle cases
            if (i0.type === i1.type) {
              all.splice(index, 1)
              // do not advance index in this case
            }
            else if ((i0.type === 'asoriginal') && (i1.type === 'final     ')) {
              all.splice(index+1, 1)
              // do not advance index in this case
            }
            else if ((i0.type === 'added     ') && (i1.type === 'final     ')) {
              all.splice(index+1, 1)
              // do not advance index in this case
            }
            else {
              index++
            }
  
          }
          else {
            index++
          }
  
  
        }
  
      }
      else {  // higher level groups - just remove duplicates

  
        for (let index = 0; index < all.length - 1; ) {
          if ((all[index].type === all[index+1].type) && (all[index].name === all[index+1].name) && (all[index].value === all[index+1].value)) {
            all.splice(index, 1)
            // do not advance index in this case
          }
          else {
            index++
          }
        }
  
  
  
      }
      
      const resultForDebuggingConsolidated = all.map(h => h.type + ' - ' + h.name + ': ' + h.value)
  
  
      //cl('stub')

    }
   

    // need to return string value
    // and also set this crg's propName+'PropItems' - will have single item, like a CRI, but being the consolidated set of headers for this webReqG
    const resultString = all.map(h => h.name + ': ' + h.value).join(' \u2B2A ')
    const resultPI: PropItemsHeaders = {
      count: 1,
      uniqueCount: 1,
      criItems: [{
        color: 0,
        modifiedCount: 0,
        item: resultString,
        object: all
      }]
    }
    crg[propName+'PropItems'] = resultPI
    return resultString


  },
  singleLineString: genericGroupedDeduped.singleLineString,
  singleLineJSX(propName: string, cr: CR): JSX.Element | string {
    if (cr[propName] === undefined) return '---'
    if (cr.group === 'yes') {
      // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
      // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
      if (cr[propName+'PropItems'] === undefined) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
    }
      //   compute max color value
      //   return span with color
      const is: PropItemsHeaders = headerPropItemsToShow(cr, cr[propName+'PropItems'])
      const maxColor = is.criItems.reduce((prev, curr) => Math.max(prev, curr.color), 0)
      return <span key='s' style = { { color: infoCellTextColors[maxColor] } }>{`(${is.criItems[0].object.length}) ${is.criItems.map(i => i.item).join(' \u2B2A ')}`}</span>
    //}
    //else {
    //  const r: PropItemsCRIItem = cr[propName+'PropItems'].criItems[0]
    //  return <span key='s' style = { { color: infoCellTextColors[r.color] } }>{r.item}</span>
    //}
  },
  multiLineString(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode): string {

    // same code as genericGroupedDeduped, except adds header .type to each header 

    if (cr[propName] === undefined) return ''
    // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
    // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
    if ((cr[propName+'PropItems'] === undefined) && (cr.group === 'yes')) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
    const is: PropItemsHeaders = headerPropItemsToShow(cr, cr[propName+'PropItems'])
    var result: string = ''
    if (includeCount && (is.count > 1)) {
      result += `(${is.count} total items, ${is.uniqueCount} unique)\n===============\n`
    }
    for (let i of is.criItems) {
      // make copy of items and sort it (making copy so as not to mutate the source array)
      const iItems = i.object.map(i => i) // already sorted by computeGroupProp  .sort((a,b) => {if (a.name < b.name) {return -1} else if (a.name === b.name) {return 0} else return 1})
      const itemString = iItems.map(io => io.type + ' - ' + io.name + ': ' + io.value).join('\n')
      result += `${CVModeTransformers[cvMode](itemString)}\n`
      // for object-backed props, the strings are likely to be multiline themselves, so put a divider between items
      if (cr[propName+'ObjectItems'] !== undefined) result += '=========================\n'
    }
    return result.slice(0, -1) // remove trailing '\n'


  },
  contentViewJSX(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode, size?: SizePropsPx): JSX.Element {
    if (cr[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
    // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
    // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
    if ((cr[propName+'PropItems'] === undefined) && (cr.group === 'yes')) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
    var splitSize: SizePropsPx | undefined
    if (size === undefined) splitSize = undefined
    else {
      splitSize = _.cloneDeep(size) as SizePropsPx
      // since the popup is often too big to fit in viewport, divide width by 3 if size constraint is 'max', else divide by 2
      splitSize.width.value = splitSize.width.value / (splitSize.width.constraint === 'max' ? 3 : 2)
    }
    return (
      <div
        style={{ display: 'flex', flexDirection: 'row'}}
      >
        <CodeMirrorView
          value={headersPropMethods.multiLineString(cr, 'reqHeaders', includeCount, 'httpHeader')}
          mode={'httpHeader'}
          size={ splitSize }
          editable={false}
        />
        <CodeMirrorView
          value={headersPropMethods.multiLineString(cr, 'resHeaders', includeCount, 'httpHeader')}
          mode={'httpHeader'}
          size={ splitSize }
          editable={false}
        />

      </div>
    )
  },
}


export const queryParamsPropMethods : TIPropFunctions = {
  hasPropItems: true,
  convertOnLoad: genericGroupedDeduped.convertOnLoad,
  testMethod: genericGroupedDeduped.testMethod,
  val: genericGroupedDeduped.val,
  active: genericGroupedDeduped.active,
  computeGroupProp(crg: CRG, children: CR[], propName: string) {

    // merge children's propItems
    const all: QueryParam[] = []

    // populate crg propItems
    for (let c of crg.children) {
      // generate the child's prop if has not be generated yet
      if ((c[propName] === undefined) && (c instanceof TIG)) queryParamsPropMethods.computeGroupProp(c, c.children, propName)
      if (c[propName] !== undefined) all.push(...c[propName+'PropItems'].criItems[0].object)
    }
    // sort by name, value
    all.sort((a, b) => { 
      if (a.name < b.name) return -1
      else if (a.name > b.name) return 1
      else if (a.value < b.value) return -1
      else if (a.value > b.value) return 1
      else return 1
    })
    // remove duplicates
    for (let index = 0; index < all.length - 1; ) {
      if ((all[index].name === all[index+1].name) && (all[index].value === all[index+1].value)) {
        all.splice(index, 1)
        // do not advance index in this case
      }
      else {
        index++
      }
    }
   
    const resultString = all.map(h => h.name + ' = ' + h.value).join(' \u2B2A ')

    crg[propName+'PropItems'] =  {
      count: 1,
      uniqueCount: 1,
      criItems: [{
        color: 0,
        modifiedCount: 0,
        item: resultString,
        object: all,
      }]
    }

    // return group string
    return resultString

  },
  singleLineString: genericGroupedDeduped.singleLineString,
  singleLineJSX(propName: string, cr: CR): JSX.Element | string {
    if (cr[propName] === undefined) return '---'
    if (cr.group === 'yes') {
      // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
      // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
      if (cr[propName+'PropItems'] === undefined) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
    }
      //   compute max color value
      //   return span with color
      const is: PropItemsQueryParams = cr[propName+'PropItems']
      const maxColor = is.criItems.reduce((prev, curr) => Math.max(prev, curr.color), 0)
      return <span key='s' style = { { color: infoCellTextColors[maxColor] } }>{`(${is.criItems[0].object.length}) ${is.criItems.map(i => i.item).join(' \u2B2A ')}`}</span>
    //}
    //else {
    //  const r: PropItemsCRIItem = cr[propName+'PropItems'].criItems[0]
    //  return <span key='s' style = { { color: infoCellTextColors[r.color] } }>{r.item}</span>
    //}
  },
  multiLineString(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode): string {

    // same code as genericGroupedDeduped, except adds header .type to each header 

    if (cr[propName] === undefined) return ''
    // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
    // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
    if ((cr[propName+'PropItems'] === undefined) && (cr.group === 'yes')) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
    const is: PropItemsQueryParams = cr[propName+'PropItems']
    var result: string = ''
    if (includeCount && (is.count > 1)) {
      result += `(${is.count} total items, ${is.uniqueCount} unique)\n===============\n`
    }
    for (let i of is.criItems) {
      // make copy of items and sort it (making copy so as not to mutate the source array)
      const iItems = i.object.map(i => i) // already sorted by computeGroupProp  .sort((a,b) => {if (a.name < b.name) {return -1} else if (a.name === b.name) {return 0} else return 1})
      const itemString = iItems.map(io => io.name + ' = ' + io.value).join('\n')
      result += `${CVModeTransformers[cvMode](itemString)}\n`
      // for object-backed props, the strings are likely to be multiline themselves, so put a divider between items
      if (cr[propName+'ObjectItems'] !== undefined) result += '=========================\n'
    }
    return result.slice(0, -1) // remove trailing '\n'


  },
  contentViewJSX(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode, size?: SizePropsPx): JSX.Element {
    if (cr[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
    // if c[propName+'PropItems'] undefined, call computeGroupProp to generate
    // look up appropriate instance of computeGroupProp from prop methods map - this function might be called from another TIPropFunctions type
    if ((cr[propName+'PropItems'] === undefined) && (cr.group === 'yes')) cr.parentTTable.tiPropFunctions[propName].computeGroupProp(cr as TIG, cr.children, propName)
    return (
      <CodeMirrorView
        value={queryParamsPropMethods.multiLineString(cr, propName, includeCount, 'none')}
        mode={'none'}
        size={ size }
        editable={false}
      />
    )
  },
}


// for props where the CRG prop should reflect the child's values,
// but if there are multiple values on the children we only return 'multiple'
// this is for props like resContent, which might be large so we don't want to create/render multiple copies of large content
export const genericGroupedSingleValue : TIPropFunctions = {
  hasPropItems: generic.hasPropItems,
  // do nothing on load - no need to create array because we will not be storing multiple values for groups
  convertOnLoad: generic.convertOnLoad,
  testMethod: generic.testMethod,
  val: generic.val,
  active: generic.active,

  computeGroupProp(tig: TIG, children: TI[], propName: string) : string | number | undefined {
    // similar to genericGroup.computedGroupProp
    // EXCEPT if children have multiple value, just return 'multiple'
    // and if there is a single unique value, return a reference to it, do not construct a new copy
    if (children.length === 0) return undefined
    var result: string | undefined = undefined

    // for each child
    //  if its value is undefined, just continue
    //  else iterate array of child's values - for each item, 
    //    if !hasResult, make this the result
    //    else if this child's value !== result, change result to 'multiple' and break
    for (let c of children) {
      if (c[propName] === undefined) continue
      else if ((c instanceof TII) && (c.testResults.hide === true)) continue  // don't include child TIIs that are hidden
      else {
        if (result !== undefined) {
          if (c[propName] !== result) {
            result = 'multiple unique values'
            // OBSOLETE if (c[propName+'Object'] !== undefined) tig[propName+'Object'] = { multiple_unique_values: true }
            // OBSOLETE break
          }
        }
        else {
          result = c[propName]
          // OBSOLETE if (c[propName+'Object'] !== undefined) tig[propName+'Object'] = c[propName+'Object']
        }
      }
    }

    return result
  },

  singleLineString: generic.singleLineString,
  singleLineJSX:    generic.singleLineJSX,
  multiLineString:  generic.multiLineString,
  contentViewJSX(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode, size?: SizePropsPx ): JSX.Element {
    if (ti[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
    else return (
      <CodeMirrorView
        value={CVModeTransformers[cvMode](ti[propName])}
        mode={cvMode}
        // OBSOLETE initialFocus={'matchInput'}
        // OBSOLETE initialMatchPattern=''
        size={ size }
        // OBSOLETE table={ti.parentTTable}
        editable={false}
      />
    )
  },

}


// array of text colors for use in single/multi line JSX
// initially used for crInfo, may use elsewhere



export const infoCellTextColors = ['black', 'blue', 'red']


export function crInfo2CompactResult(cr: CR): string {
  let u: URL | undefined = undefined
  let hostnameAndPath: string | undefined = undefined
  let lastPartOfUrlPath: string | undefined = ''
  try {
    u = new URL(cr.url)
    hostnameAndPath = u.host + '/' + u.pathname
    lastPartOfUrlPath = u.pathname.split('/').pop()
    if (lastPartOfUrlPath === undefined) lastPartOfUrlPath = '/'
    else lastPartOfUrlPath = '/' + lastPartOfUrlPath
  }
  catch {}

  var resultString: string = ''
  var resultColor: number = 1

  switch (cr.kind) {
    case 'webNavI':
    case 'webNavG':
      resultString += `webNav: ${cr.transitionType} - ${cr.transitionQualifiers} - ${hostnameAndPath}`
      break
    case 'webReqI':
    case 'webReqG':
    case 'dNRMatchI':
      resultString += `${cr.method} (${cr.resourceType}) ${lastPartOfUrlPath}`
      break
    case 'harI':
      // change resource types included in har to corresponding values in webReq
      // don't know why har resource types are sometimes different from webReq
      // the range of values that har might report is undocumented, as far as I can tell
      // so i am just doing this mapping based on observed traffic
      let resourceTypeToShow: string = cr.resourceType
      if (resourceTypeToShow === 'document') resourceTypeToShow = 'main_ or sub_frame'
      if (resourceTypeToShow === 'xhr') resourceTypeToShow = 'xmlhttprequest'
      if (resourceTypeToShow === 'fetch') resourceTypeToShow = 'xmlhttprequest'
      resultString += `${cr.method} (${resourceTypeToShow}) ${lastPartOfUrlPath}`
      break
    default:
      return 'WHAT DO WE WANT FOR THIS KIND OF CR???'
  }
  if (cr.method === 'POST') resultColor = 2
  return resultColor.toString() + resultString
}


export function crInfo2VerboseResult(cr: CR): string {
  let u: URL | undefined = undefined
  let hostnameAndPath: string | undefined = undefined
  let lastPartOfUrlPath: string | undefined = ''
  try {
    u = new URL(cr.url)
    hostnameAndPath = u.host + '/' + u.pathname
    lastPartOfUrlPath = u.pathname.split('/').pop()
    if (lastPartOfUrlPath === undefined) lastPartOfUrlPath = '/'
    else lastPartOfUrlPath = '/' + lastPartOfUrlPath
  }
  catch {}

  var resultString: string = ''
  var resultColor: number = 1

  switch (cr.kind) {
    case 'webNavI':
    case 'webNavG':
    case 'dNRMatchI':
      resultString = 
`webNavigation:
  transitionType: ${cr.transitionType}
  transitionQualifiers:
  hostname and path: ${hostnameAndPath}`
      break
    case 'webReqI':
    case 'webReqG':
      resultString = 
`webRequest:
  method: ${cr.method}
  resource type: ${cr.resourceType}
  end of path: ${lastPartOfUrlPath}
  res status code: ${cr.resStatusCode}`
      break
    case 'harI':
      // change resource types included in har to corresponding values in webReq
      // don't know why har resource types are sometimes different from webReq
      // the range of values that har might report is undocumented, as far as I can tell
      // so i am just doing this mapping based on observed traffic
      let resourceTypeToShow: string = cr.resourceType
      if (resourceTypeToShow === 'document') resourceTypeToShow = 'main_ or sub_frame'
      if (resourceTypeToShow === 'xhr') resourceTypeToShow = 'xmlhttprequest'
      if (resourceTypeToShow === 'fetch') resourceTypeToShow = 'xmlhttprequest'
      resultString =
`har:
  method: ${cr.method}
  resource type: ${resourceTypeToShow}
  end of path: ${lastPartOfUrlPath}
  res status code: ${cr.resStatusCode}`
      break
    default:
      return 'WHAT DO WE WANT FOR THIS KIND OF CR?'
  }
  if (cr.method === 'POST') resultColor = 2
  return resultColor.toString() + resultString
}


export const crInfo2 : TIPropFunctions = {
  hasPropItems: genericGroupedDeduped.hasPropItems,
  // conversion to apply on loading from mongo into TTable
  convertOnLoad: genericGroupedDeduped.convertOnLoad,
  testMethod: genericGroupedDeduped.testMethod,
  val: genericGroupedDeduped.val,
  active: genericGroupedDeduped.active,
  computeGroupProp: genericGroupedDeduped.computeGroupProp,
  singleLineString(propName: string, cr: CR): string {
    if ((cr.group === 'yes') && (cr.kind !== 'webReqG')) return genericGroupedDeduped.singleLineString(propName, cr)
    else return crInfo2CompactResult(cr).slice(1)
  },
  singleLineJSX(propName: string, cr: CR): JSX.Element | string {
    if ((cr.group === 'yes') && (cr.kind !== 'webReqG')) {
      // parse the prop (will have been computed by generic...computeGroupProp)
      //   strip out the color numbers and re-assemble
      //   compute max color value
      //   return span with color
      var parts: string[] = cr[propName].split('\n')
      const maxColor = parts.map(p => Number.parseInt(p.slice(0,1))).reduce((prev, curr) => Math.max(prev, curr), 0)
      parts = parts.map(p => p.slice(1))
      return <span key='s' style = { { color: infoCellTextColors[maxColor] } }>{`${(parts.length > 1) ? '('+parts.length.toString()+') ' : ''}${parts.join(', ')}`}</span>
    }
    else {
      const r = crInfo2CompactResult(cr)
      return <span key='s' style = { { color: infoCellTextColors[Number.parseInt(r.slice(0,1))] } }>{r.slice(1)}</span>
    }
  },
  multiLineString(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode): string {
    if (cr[propName] === undefined) return ''
    else if (cr.group === 'yes') return genericGroupedDeduped.multiLineString(cr, propName, includeCount, cvMode)
    else return crInfo2VerboseResult(cr).slice(1)
  },
  contentViewJSX(cr: CR, propName: string, includeCount: boolean, cvMode: CVMode): JSX.Element {
    if (cr[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
    var parts: string[] = cr[propName].split('\n')
    if ((cr.group === 'yes') ) {
      // similar to singleLineJSX
      return <div>
          {(parts.length > 1) ? <pre key='count'>{`(${parts.length} unique items)\n============`}</pre> : ''}
          {
            parts.map((p,i) => <pre key={i} style = { { color: infoCellTextColors[Number.parseInt(p.slice(0, 1))] } }>{p.slice(1)}</pre>)
          }
        </div>
    } 
    else {
      const r = crInfo2VerboseResult(cr)
      return (
        <div className='ttCellMultiLineJSX' style = { { color: infoCellTextColors[Number.parseInt(r.slice(0,1))] } }>
          {
            r.slice(1).split('\n').map(ri => <pre>{ri}</pre>)
          }
        </div>
      )
    }
  },

}























const resourceTypesInWebReq = 'main_frame sub_frame image font stylesheet media script other manifest xmlhttprequest ping'



// computes crExceptions string
// returns a '\n' delimited string with exceptions, suitable for aggregation by
//    genericGroupedAsList* so we need to remove the trailing '\n'
// or returns undefined if there are none
// this is factored out to a separate function because the same code is needed in multiple places
//    in CRI for computed CRI value (webNavI | webReqI | harI )
//    below, to compute for CRGs
export function crExceptionsString(cr: CR): string | undefined {
  let exceptionsToAdd: string = ''
  let expectedPattern: boolean = false  // false by default, which will create an exception message
                              // will only be turned true if CRI meets all criteria for an expected pattern

 //  PATTERNS THAT ARE EXPECTED IN TRAFFIC, AND NO EXCEPTION WILL BE REPORTED:
 //  for CRIs
 //    wrOnCompleted
 //      resStatusCode      error         reqWasTested  reqDecisionResult   reqOutcome   reqRuleTypes...  jsWasTested   jsDecisionResult    jsOutcome
 //      string && !== '0'  <undefined>   false         allow               allowed      undefined        false         allow               allowed
 //           NOTE - NOT GOING TO CONSIDER CASES WHERE REQWASTESTED AND JSWASTESTED ARE NOT THE SAME TO BE 'EXPECTED' PATTERNS - WE WILL BE REMOVING THIS OPTION (AND IT WILL NOT BE FEASIBLE IN DNR ANYWAY)
 //      string && !== '0'  <undefined>   true          deny                blocked      anyhost|specific undefined     undefined           undefined
 //      string && !== '0'  <undefined>   true          allow               allowed      anyhost|specific true          deny                blocked
 //      string && !== '0'  <undefined>   true          allow               allowed      anyhost|specific true          allow               allowed
 //    wrOnErrorOccurred
 //      resStatusCode      error                          reqWasTested  reqDecisionResult   reqOutcome    jsDecision    jsOutcome
 //      <undefined>        net::ERR_BLOCKED_BY_CLIENT     true          deny                blocked       
 //      <undefined>        net::ERR_CACHE_MISS            
 //    wrOnBeforeRedirect
 //      TBD TBD TBD need to observe patterns
 //    wrOnAuthRequired
 //      TBD TBD TBD need to observe some of these
 //    harI
 //      resStatusCode      error                          reqDecision   reqOutcome    jsDecision    jsOutcome
 //      string not '0'     null                                         allowed                     allowed|blocked
 //      '0'                net::ERR_BLOCKED_BY_CLIENT                   blocked
 //      '0'                net::ERR_CACHE_MISS
 //      '0'                ''          AND initiator was parser AND ttable.urlWOFragDict[initURL].jsOutcome === 'blocked'
 //                                      ^  MAKE THIS ANOTHER COMPUTED PROP IN CRI
 //                                      access initiatorObject[0].type and .url
  switch (cr.kind) {
    case 'webReqI':
      switch (cr.event) {
        case 'wrOnAuthRequired':
          // if <meets all conditions for expected pattern> do nothing, else report exception
          exceptionsToAdd += 'found a webReq onAuthRequired event - needs further analysis for what the expected pattern is\n'
          break
        case 'wrOnBeforeRedirect':
          // if <meets all conditions for expected pattern> do nothing, else report exception
          if ((cr.reqDecisionResult === 'allow') || (cr.reqWasTested === 'false')) expectedPattern = true
          if (expectedPattern === false) exceptionsToAdd += 'found a webReq onBeforeRedirect event - needs further analysis for what the expected pattern is\n'
          break
        case 'wrOnCompleted':
          // if <meets all conditions for expected pattern> do nothing, else report exception
          if ((typeof cr.resStatusCode === 'string') && (cr.resStatusCode !== '0') && (cr.error === undefined)) {
            if (cr.reqWasTested === 'false') {
              if ((cr.reqRuleTypesThatAffected === 'undefined') && (cr.reqDecisionResult === 'allow')) expectedPattern = true
            }
            else if ((cr.reqWasTested === 'true') && ((cr.reqRuleTypesThatAffected === 'anyhost') || (cr.reqRuleTypesThatAffected === 'specific'))) {   // can't just assume reqWasTested is true - it could be undefined
              if (cr.reqDecisionResult === 'deny') {
                if ((cr.reqOutcome === 'blocked') && (cr.jsWasTested === undefined) && (cr.jsOutcome === undefined)) expectedPattern = true 
              } 
              else if (cr.reqDecisionResult === 'allow') {
                if ((cr.reqOutcome === 'allowed') && (cr.jsWasTested === 'true')) {
                  if      ((cr.jsDecisionResult === 'deny' ) && (cr.jsOutcome === 'blocked')) expectedPattern = true
                  else if ((cr.jsDecisionResult === 'allow') && (cr.jsOutcome === 'allowed')) expectedPattern = true
                }
              }
            }
          }
          if (expectedPattern === false) exceptionsToAdd += 'unrecognized pattern in a webReqI\n'
          // note this is same code as for harI - keep them in sync
          const resHdr = (cr.resHeadersSummary === undefined) ? '' : cr.resHeadersSummary.toLowerCase()
          const cspPresent = resHdr.includes('content-security-policy')
          const cspIncludesUnsafe = cspPresent
            ? ((resHdr.includes('unsafe')) || (resHdr.includes('nonce-')) || (resHdr.includes('sha')))
            : false
          if (cspIncludesUnsafe) exceptionsToAdd += 'CSP includes unsafe|nonce|sha\n'
    
          break
        case 'wrOnErrorOccurred':
          // if <meets all conditions for expected pattern> do nothing, else report exception
          if (cr.resStatusCode === undefined) {
            if ((cr.error === 'net::ERR_BLOCKED_BY_CLIENT') && (cr.reqWasTested === 'true') && (cr.reqDecisionResult === 'deny') && (cr.reqOutcome === 'blocked')) expectedPattern = true
            else if (cr.error === 'net::ERR_CACHE_MISS') expectedPattern = true
          }
          if (expectedPattern === false) exceptionsToAdd += 'unrecognized pattern in a webReqI\n'
          break
        default:
          break
      }
 
      if (resourceTypesInWebReq.includes(cr.resourceType) === false) exceptionsToAdd += 'Unknown resource type\n'
      if (cr.resourceType === 'sub_frame') exceptionsToAdd += 'Subframe\n'
      break
    case 'harI':
      // if <meets all conditions for expected pattern> do nothing, else report exception
      if (typeof cr.resStatusCode === 'string') {
        if     ((cr.resStatusCode !== '0') && (cr.error === 'null') && (cr.reqOutcome === 'allowed') && ((cr.jsOutcome === 'allowed') || (cr.jsOutcome === 'blocked'))) expectedPattern = true
        else if (cr.resStatusCode === '0') {
          if      ((cr.error === 'net::ERR_BLOCKED_BY_CLIENT') && (cr.reqOutcome === 'blocked')) expectedPattern = true
          else if  (cr.error === 'net::ERR_CACHE_MISS') expectedPattern = true
          else if ((cr.error === '') && (cr.harParserInitJSOutcome === 'parser initiated, init jsOutcome: blocked')) expectedPattern = true
        }
      }
      if (expectedPattern === false) exceptionsToAdd += 'unrecognized pattern in a harI\n'
      // note this is same code as for webReqI - keep them in sync
      const resHdr = (cr.resHeadersSummary === undefined) ? '' : cr.resHeadersSummary.toLowerCase()
      const cspPresent = resHdr.includes('content-security-policy')
      const cspIncludesUnsafe = cspPresent
        ? ((resHdr.includes('unsafe')) || (resHdr.includes('nonce-')) || (resHdr.includes('sha')))
        : false
      if (cspIncludesUnsafe) exceptionsToAdd += 'CSP includes unsafe|nonce|sha\n'
      // change resource types included in har to corresponding values in webReq
      // don't know why har resource types are sometimes different from webReq
      // the range of values that har might report is undocumented, as far as I can tell
      // so i am just doing this mapping based on observed traffic
      let resourceTypeToShow: string = cr.resourceType
      if (resourceTypeToShow === 'document') resourceTypeToShow = 'main_frame'
      if (resourceTypeToShow === 'xhr') resourceTypeToShow = 'xmlhttprequest'
      if (resourceTypeToShow === 'fetch') resourceTypeToShow = 'xmlhttprequest'
      if (resourceTypesInWebReq.includes(resourceTypeToShow) === false) exceptionsToAdd += 'Unknown resource type\n'
      break
    default:
      break
  }
  return (exceptionsToAdd === '') ? undefined : exceptionsToAdd.slice(0, -1)
}



     /*
      IN GENERAL, TEST FOR *EXPECTED* PATTERNS AND MAKE EXCEPTION IF ANYTHING UNEXPECTED
      
      for CRGs
        urlG will have equal number of webReqG and harI
          all have same url, but may be different headers - sometimes headers specify what resource type is being requested, or maybe something else that distinguishes different requests
          except there can be a harI but no webReqG if another webReqG loaded some html with inline javascript but js was blocked for that request
            in which case, the browser still produces a harI from that inline javascript, but no webReq
              and the harI will 'fail' with statusCode '0' and error==='' (not null or any other error message)

      WRITE OUT TABLE OF EXPECTED PATTERNS
      THEN WRITE PSEUDOCODE TO TEST FOR UN-EXPECTED PATTERNS


         need to also handle internal redirects
            review what the 'expected pattern' is for internal redirects
                what will show up for webReq?
                what will show up for har?
            document 'expected patterns' for redirects
                it appears that (at least) for internal redirects, the redirected request has a webReq that reflects the script-src 'none' header mod
                   but the associated harI does not have the header mod
                   example:  load drudgereport from bookmark
                   WTF?
        need to also handle onAuthRequired patterns
          for now, just report exception if webReq includes onAuthRequired

         other exceptions to parse out
          cr.reqOutcome undefined, or reqOutcome 'allowed' but jsOutcome undefined
          reqOutcome 'blocked' but no rule (this might not be an error, but i want to highlight it)
          reqOutcome not 'allowed' 'blocked' or 'failed cache miss' - copy error message
          reqOutcome or jsOutcome includes 'INDETERMINATE'
          harI failed and no error message EXCEPT (initiator was parser AND (lookup urlG.jsOutcome of initiator urlG in table.urlgWOFragDict is not 'denied'))
       then view traffic and consider urlG-level exceptions
          1) if has a harI that is BLOCKED_BY_CLIENT but no webReq with that outcome, report exception
          2) harI-to-webReqG map not clean (either 1->1 or har has parser init with js blocked)

*/


// exception info messages
// will be computed in CRIs, and aggregated using groupedAsListKeepDups
// computeGroupProp will aggregate childrens' exceptions, and add more based on group-level exception checking
// code that populates the CRI value needs to make sure trailing \n's are removed
// JSX will show in red, bold
export const crExceptions : TIPropFunctions = {
  hasPropItems: genericGroupedDeduped.hasPropItems,
  // conversion to apply on loading from mongo into TTable
  convertOnLoad: genericGroupedDeduped.convertOnLoad,
  testMethod: genericGroupedDeduped.testMethod,
  val: genericGroupedDeduped.val,
  active: genericGroupedDeduped.active,
  computeGroupProp(crg: CRG, children: TI[], propName: string) : string | number | undefined {
    // compute tiExceptions for group here
    //   aggregate exceptions from children
    //   add exceptions detected at this group level
    let fromChildren: string | number | undefined = genericGroupedDeduped.computeGroupProp(crg, children, propName)
    let additional: string = ''
    switch (crg.kind) {
      default:
        case 'webNavG':
          // instead compute from children WITHOUT duplicates, so we only show one of each exception for the whole group
          fromChildren = genericGroupedDeduped.computeGroupProp(crg, children, propName)
          break
        case 'webReqG':
          // instead compute from children WITHOUT duplicates, so we only show one of each exception for the whole group
          fromChildren = genericGroupedDeduped.computeGroupProp(crg, children, propName)
          if (crg.reqOutcome === undefined) additional += 'no req outcome for a webReqG\n'
          break
        case 'urlG':
          // exception for certain kinds of non-http urls
          if (crg.url.slice(0, 4) !== 'http') {
            // about:blank is OK
            if (crg.url === 'about:blank') additional += ''
            // data: may or may not be OK - need to test it further
            else if (crg.url.slice(0,5) === 'data:') {
              // see notes in onenote on data urls
              // generally they are OK, but flag any that start with: 'data:text/html...' and 'data:application/x-javascript...'
              if ((/^data:text\/html/.test(crg.url)) || (/^data:application\/x-javascript/.test(crg.url))) additional += 'data url with html or js mimetype\n'
            }
            else if (crg.url.slice(0,4) === 'blob') additional += 'blob url - examine this\n'
            // else report exception
            else additional += 'questionable non-http url\n'
          }
          // report if number of hars (excluding parser initiated but js blocked) !== number of webReqGs
          let harCount: number = 0
          let webReqGCount: number = 0
          for (let c of crg.children) {
            if (
              (c.kind === 'webReqG')
              && (c.error !== 'net::ERR_CACHE_MISS')
            ) webReqGCount++
            else if (
              (c.kind === 'harI')
              && (
                (c.url.slice(0,4) === 'http')    // don't count hars for non-http urls (e.g., blob:, data:) - there will be no webReq
                && (c.harParserInitJSOutcome !== 'parser initiated, init jsOutcome: blocked')  // don't count hars that were parser initiated and js was blocked for the initiator - there will be no webReq
                && (/browser\.events\.data\.msn\.com/.test(c.url) === false)    // ignore these - there will be no webReq for these, and can't block them with extension (they should be blocked by pihole though)
              ) 
            ) harCount++
          }
          if (harCount !== webReqGCount) additional += 'mismatched numbers of webReqGs vs harIs\n'
          break
    }

    // cases:  fromChildren could be undefined or contain >=1 values
    //          additional could be '' or contain >= 1 values
    let result = ''
    if (fromChildren !== undefined) result += fromChildren + '\n'
    if (additional !== '') result += additional

    return (result === '') ? undefined : result.slice(0, -1)

  },
  singleLineString: genericGroupedDeduped.singleLineString,
  singleLineJSX(propName: string, ti: TI): JSX.Element | string {
    if (ti[propName] === undefined) return '---'
    else return <span key='s' style={{color: 'red'}}><b>{genericGroupedDeduped.singleLineString(propName, ti)}</b></span>
  },
  multiLineString: genericGroupedDeduped.multiLineString,
  contentViewJSX: genericGroupedDeduped.contentViewJSX,

}





// for the nameValueString prop in OI's
export const nameValueString : TIPropFunctions = {
  hasPropItems: generic.hasPropItems,
  // conversion to apply on loading from mongo into TTable
  convertOnLoad: generic.convertOnLoad,
  testMethod: generic.testMethod,
  val: generic.val,
  active: generic.active,
  computeGroupProp: generic.computeGroupProp,

  singleLineString: generic.singleLineString,
  singleLineJSX(propName: string, ti: TI): JSX.Element | string {
    const s = nameValueString.singleLineString(propName, ti)
    const name = s.split(':', 1)[0]
    const rest = s.slice(name.length)
    return <pre><b>{name}</b>{rest}</pre>
  },
  multiLineString: generic.multiLineString,
  contentViewJSX(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): JSX.Element {
    const s = nameValueString.singleLineString(propName, ti)
    const name = s.split(':', 1)[0]
    const rest = s.slice(name.length)
    return <div className='ttCellMultiLineJSX'><pre key='pre1'><b>{name}</b>{rest}</pre></div>
  },

}


// provides specific JSX for the decisionAndOutcomeSummary prop
export const outcomeSummary : TIPropFunctions = {
  hasPropItems: genericGroupedDeduped.hasPropItems,
  // conversion to apply on loading from mongo into TTable
  convertOnLoad: genericGroupedDeduped.convertOnLoad,
  testMethod: genericGroupedDeduped.testMethod,
  val: genericGroupedDeduped.val,
  active: genericGroupedDeduped.active,
  computeGroupProp: genericGroupedDeduped.computeGroupProp,

  singleLineString: genericGroupedDeduped.singleLineString,
  singleLineJSX(propName: string, ti: TI, rowIndex: number, colIndex: number): JSX.Element | string {
    const s = outcomeSummary.singleLineString(propName, ti)
    if (s === undefined) return '---'
    else {
      const p: string[] = s.split(' ')
      return <span key='s'>{p.map((pi, i) => <span key={i}>{((pi === 'allow') || (pi === 'block')) ? <b>{pi}</b> : pi} </span>)}</span>
    }
  },
  multiLineString: genericGroupedDeduped.multiLineString,
  contentViewJSX(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): JSX.Element {
    return genericGroupedDeduped.contentViewJSX(ti, propName, includeCount, cvMode)
  },

}







// timezone offset value, for use in TII and TIG timeStamp cell content values
const tzOffset: number = (new Date(0)).getTimezoneOffset()

export const timeStampMin : TIPropFunctions = {
  hasPropItems: generic.hasPropItems,
  // conversion to apply on loading from mongo into TTable
  convertOnLoad(cr: {[index: string]: any}, propName: string): void { return },
  testMethod: generic.testMethod,
  val: generic.val,
  active: generic.active,
  computeGroupProp(tig: TIG, children: TI[], propName: string) : number | undefined {
      if (children.length === 0) return 0
      else return Math.min(...children.map(c => c[propName]))
  },

  singleLineString(propName: string, ti: TI): string {
      if (ti[propName] === undefined) return '---'
      let dateString =  (new Date(ti[propName]+tzOffset)).toISOString()
      return dateString.slice(12) + ' ' + dateString.slice(0, 11)
  },

  singleLineJSX(propName: string, ti: TI): JSX.Element | string { 
    return timeStampMin.singleLineString(propName, ti)
  },
  multiLineString(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): string {
    if (ti[propName] === undefined) return ''
    else return CVModeTransformers[cvMode](timeStampMin.singleLineString(propName, ti))
  },
  contentViewJSX(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): JSX.Element {
    if (ti[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
    else return <div className='ttCellMultiLineJSX'>{CVModeTransformers[cvMode](timeStampMin.singleLineString(propName, ti))}</div>
  },
  

}

export const timeStampMax : TIPropFunctions = {
  hasPropItems: generic.hasPropItems,
  // conversion to apply on loading from mongo into TTable
  convertOnLoad: timeStampMin.convertOnLoad,
  testMethod: generic.testMethod,
  val: generic.val,
  active: generic.active,
  computeGroupProp(tig: TIG, children: TI[], propName: string) : number | undefined {
      if (children.length === 0) return 0
      else return Math.max(...children.map(c => c[propName]))
  },
  singleLineString: timeStampMin.singleLineString,
  singleLineJSX:    timeStampMin.singleLineJSX,
  multiLineString:  timeStampMin.multiLineString,
  contentViewJSX:     timeStampMin.contentViewJSX,
}





// convention/inteface
//  mapPMViewer and mapPMServer are objects with property names corresponding to properties in a TI
//      mostly, these are properties that are displayed in a column in the viewer
//      there can also be entries for "helper" properties to be created in the TI that are not displayed in a column
//                  directly, e.g., for reqHeadersHaveBinaryData
//      mapPMViewer - the value of each property is a reference to the object containing the utilty functions specific to that property
//          see interface definition above for the utility function specs

export const mapPMViewerObj: {[index: string]: TIPropFunctions} = {
  tiInfo                : generic,
  kind                  : generic,
  name                  : generic,
  value                 : generic,
  nameValueString       : nameValueString,
  type                  : generic,
  size                  : generic,
  level                 : generic,
  parents               : generic,
}


/*
  props that have backing objects must use the 'genericGroupedAsArray'
  since that one manages the backing object along with the string prop
  (also, the string prop can include \n's, so ...AsList won't work)
    cache
    initiator
    queryString
    reqCookies
    reqHeaders
    resCookies
    resHeaders
    resContent
*/
export const mapPMViewerCR: {[index: string]: TIPropFunctions} = {
  tiInfo                   : generic,
  crInfo2                 : crInfo2,
  crExceptions             : crExceptions,
  domain2                   : genericGroupedDeduped, // genericGroupedAsListNoDups,
  dNRRuleDisplay                 : genericGroupedDeduped,
  outcomeSummary  : outcomeSummary,
  reqOutcome                : genericGroupedDeduped,
  jsOutcome                : genericGroupedDeduped,

  reqHeaders                     : headersPropMethods, // genericGroupedAsJSONArrayKeepDups,   // has backing object
  resHeaders                     : headersPropMethods, //  genericGroupedAsJSONArrayKeepDups,   // has backing object

  // OBSOLETE OR WILL BE ADAPTED reqHeadersSummary              : headersPropMethods, //  genericGroupedAsListNoDups,
  // OBSOLETE OR WILL BE ADAPTED resHeadersSummary              : genericGroupedDeduped,

  // OBSOLETE OR WILL BE ADAPTED reqHdrModOutcome               : genericGroupedDeduped,
  // OBSOLETE OR WILL BE ADAPTED resHdrModOutcome               : genericGroupedDeduped,


  // OBSOLETE reqHdrModDecisionResult        : genericGroupedAsListNoDups,
  // OBSOLETE reqHdrModDecisionMods          : genericGroupedAsListNoDups,
  // OBSOLETE reqHdrModWasTested             : genericGroupedAsListNoDups,
  // OBSOLETE reqHdrModRuleTypesThatAffected : genericGroupedAsListNoDups,


  // OBSOLETE resHdrModDecisionResult        : genericGroupedAsListNoDups,
  // OBSOLETE resHdrModDecisionMods          : genericGroupedAsListNoDups,
  // OBSOLETE resHdrModWasTested             : genericGroupedAsListNoDups,
  // OBSOLETE resHdrModRuleTypesThatAffected : genericGroupedAsListNoDups,

  queryParams             : queryParamsPropMethods,

  reqDecisionResult      : genericGroupedDeduped,
  reqWasTested : genericGroupedDeduped,
  reqRuleTypesThatAffected: genericGroupedDeduped,
  configItemsThatAffectedReqInBrowser : genericGroupedDeduped,
  jsDecisionResult          : genericGroupedDeduped,
  jsWasTested: genericGroupedDeduped,
  jsRuleTypesThatAffected: genericGroupedDeduped,
  configItemsThatAffectedJSInBrowser : genericGroupedDeduped,
  configItemsThatAffectedReqHdrsInBrowser : genericGroupedDeduped,
  configItemsThatAffectedResHdrsInBrowser : genericGroupedDeduped,
  harParserInitJSOutcome       : genericGroupedDeduped,
  reqCookiesSummary        : genericGroupedDeduped,
  resCookiesSummary        : genericGroupedDeduped,
  requestOriginHeader      : genericGroupedDeduped,
  initOrigins              : genericGroupedDeduped,  
  initOriginMostLocal      : genericGroupedDeduped,  
  initOriginMostGlobal     : genericGroupedDeduped,
  initAnyNonURLs           : genericGroupedDeduped,
  initURLs                 : genericGroupedDeduped,
  _id                      : generic,
  kind                     : generic,
  tabIdInit                : genericGroupedDeduped,
  event                    : genericGroupedDeduped,
  machine                  : genericGroupedDeduped,
  // OBSOLETE run                      : genericGroupedAsListNoDups,
  tabId                    : genericGroupedDeduped,
  timeStampMin             : timeStampMin,
  timeStampMax             : timeStampMax,
  hostname                 : genericGroupedDeduped,
  url                      : genericGroupedDeduped, 
  urlWOFrag                : genericGroupedDeduped,
  urlFrag                  : genericGroupedDeduped,
  processId                : genericGroupedDeduped,
  sourceTabId              : genericGroupedDeduped,
  sourceProcessId          : genericGroupedDeduped,
  sourceFrameId            : genericGroupedDeduped,
  replacedTabId            : genericGroupedDeduped,
  transitionType           : genericGroupedDeduped,
  transitionQualifiers     : genericGroupedDeduped,
  error                    : genericGroupedDeduped,
  frameId                  : genericGroupedDeduped,
  parentFrameId            : genericGroupedDeduped,
  requestId                : genericGroupedDeduped,
  scheme                   : genericGroupedDeduped,
  realm                    : genericGroupedDeduped,
  challenger               : genericGroupedDeduped,
  isProxy                  : genericGroupedDeduped,
  method                   : genericGroupedDeduped,   // genericGroupedAsListNoDups,
  resourceType             : genericGroupedDeduped,
  initiator                : initiator,   // has backing object
  resStatusCode            : genericGroupedDeduped,
  resStatusLine            : genericGroupedDeduped,
  ip                       : genericGroupedDeduped,
  cache                    : genericGroupedKeepDups,  // has backing object
  redirectUrl              : genericGroupedDeduped,

  reqBodyInfo              : genericGroupedDeduped,
  reqBody                  : genericGroupedKeepDups,
  postDataInfo             : genericGroupedDeduped,
  postData                 : genericGroupedKeepDups,

  connection               : genericGroupedDeduped,
  reqHttpVersion           : genericGroupedDeduped,
  reqHeadersSize           : genericGroupedDeduped,
  reqBodySize              : genericGroupedDeduped,
  queryObject              : genericGroupedKeepDups,
  queryString              : genericGroupedKeepDups,   // has backing object
  reqCookies               : genericGroupedKeepDups,   // has backing object
  resHttpVersion           : genericGroupedDeduped,
  resHeadersSize           : genericGroupedDeduped,
  resBodySize              : genericGroupedDeduped,
  res_transferSize         : genericGroupedDeduped,
  resCookies               : genericGroupedKeepDups,   // has backing object
  resContent               : genericGroupedSingleValue,   // revise ...SingleValue
  mimeType                 : genericGroupedDeduped,
  getContent               : genericGroupedSingleValue,  
  getContentLength         : genericGroupedDeduped,
  getContentEncoding       : genericGroupedDeduped,

}





// OBSOLETE // for props where we aggregate multiple values as JSON.stringified array
// OBSOLETE // and also represent values in TII's as a JSON.stringified array
// OBSOLETE // also manage backing source objects
// OBSOLETE // note - unlike earlier implementation, we do NOT remove duplicates in computeGroupProp
// OBSOLETE // rather, we count duplicates in the [single|multi]line[String|JSX] methods
// OBSOLETE function getUniquesAndCountsForGenericGroupedAsJSONArrayKeepDups(s: string): { total: number, counts: { [index: string]: number } } {
// OBSOLETE   // this is all we need to do, since even a single-valued prop will be a JSON.stringified array
// OBSOLETE   const items = JSON.parse(s)
// OBSOLETE   const counts = _.countBy(items)
// OBSOLETE   return {
// OBSOLETE     total: items.length,
// OBSOLETE     counts: counts
// OBSOLETE   }
// OBSOLETE }
// OBSOLETE export const genericGroupedAsJSONArrayKeepDups : TIPropFunctions = {
// OBSOLETE   // conversion to apply on loading from mongo into TTable
// OBSOLETE   //   converts value from mongo to an array with one element
// OBSOLETE   //   (we make it an array so that its structure will parallel the structure of the prop for a group, which will be an array of the child values)
// OBSOLETE   //   and then JSON.stringifies it so that the stored value is a string (for application of tests)
// OBSOLETE   //   also, if there is a shadow copy of the source object, enclose that in an array, for similar reasons
// OBSOLETE   convertOnLoad(cr: {[index: string]: any}, propName: string): void {
// OBSOLETE     cr[propName] = JSON.stringify([cr[propName]]) 
// OBSOLETE     if (cr[propName+'Object'] !== undefined) cr[propName+'Object'] = [cr[propName+'Object']]
// OBSOLETE   },
// OBSOLETE   testMethod: generic.testMethod,
// OBSOLETE   val: generic.val,
// OBSOLETE   active: generic.active,
// OBSOLETE   computeGroupProp(tig: TIG, children: TI[], propName: string) : string | number | undefined {
// OBSOLETE     // these notes are old - may want to re-test
// OBSOLETE       // from testing for redundant re-computations of group props
// OBSOLETE       // observations/conclusions
// OBSOLETE       //   1) all get recomputed when a TIG is expanded, because the TTable.expandTI method calls sortTIG, which replaced children with a new array
// OBSOLETE       //     -- this is OK, because the recomputations are only done for the newly expanded TIG, not for the entire dataset
// OBSOLETE       //   2) when new TI's get added to a TIG when CRs are loading, the grouping props get recomputed each time a new child is added
// OBSOLETE       //     -- this is redundant since for groupingprops, every child will have the same value by definition
// OBSOLETE       //     -- for now we will not try to optimize around this, but maybe worthwhile if performance profiling shows this to be a hotspot
// OBSOLETE       //cl(`    computing group prop '${propName}' for tig kind '${tig.kind}', child kinds: ${children.map(c=>c.kind)}`)
// OBSOLETE       //    if (tig instanceof TIHG) if (tig.groupingPropNames.indexOf(propName) !== -1) cl(`      propName is a grouping propname`)
// OBSOLETE 
// OBSOLETE     if (children.length === 0) return undefined
// OBSOLETE     const resultArray: string[] = []
// OBSOLETE     const resultObjectArray: Object[] = []
// OBSOLETE 
// OBSOLETE     // for each child
// OBSOLETE     //  if its value is undefined, just continue
// OBSOLETE     //  else iterate array of child's values - for each item, if it is not already in resultArray, push onto the array
// OBSOLETE     //  then do the same for shadow objects, if they exist
// OBSOLETE 
// OBSOLETE     for (let c of children) {
// OBSOLETE       if (c[propName] === undefined) continue
// OBSOLETE 
// OBSOLETE       // OMIT CHILD IF HIDDEN
// OBSOLETE       if (c.testResults.hide) continue
// OBSOLETE 
// OBSOLETE       else {
// OBSOLETE         let cvs: string[] = JSON.parse(c[propName])
// OBSOLETE         for (let i = 0; i < cvs.length; i++) {
// OBSOLETE           // OBSOLETE - NOT REDUCING TO UNIQUE VALUES if (resultArray.indexOf(cvs[i]) === -1) {
// OBSOLETE             resultArray.push(cvs[i])
// OBSOLETE             if (c[propName+'Object'] !== undefined) resultObjectArray.push(c[propName+'Object'][i])
// OBSOLETE           //}
// OBSOLETE         }
// OBSOLETE       }
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE     if (resultArray.length === 0) return undefined
// OBSOLETE     else {
// OBSOLETE       // create prop on this tig with resultObjectArray - we are not returning this
// OBSOLETE       if (resultObjectArray.length > 0) tig[propName+'Object'] = resultObjectArray
// OBSOLETE       return JSON.stringify(resultArray)
// OBSOLETE     }
// OBSOLETE   },
// OBSOLETE 
// OBSOLETE   singleLineString(propName: string, ti: TI): string {
// OBSOLETE       if (ti[propName] === undefined) return '---'
// OBSOLETE       else {
// OBSOLETE         const counts = getUniquesAndCountsForGenericGroupedAsJSONArrayKeepDups(ti[propName])
// OBSOLETE         const items = Object.getOwnPropertyNames(counts.counts).sort()   // we sort here but not in multiLineString (ContentView has a 'sorted' mode)
// OBSOLETE         let result: string = ''
// OBSOLETE         if (counts.total > 1) {
// OBSOLETE           result += `(${counts.total}t`
// OBSOLETE           if (items.length > 1) result += `/${items.length}u) `
// OBSOLETE           else result += ') '
// OBSOLETE         }
// OBSOLETE         for (let i of items) result += `${i}, `
// OBSOLETE         return result.slice(0, -2) // remove trailing ', '
// OBSOLETE       }
// OBSOLETE   },
// OBSOLETE   singleLineJSX(propName: string, ti: TI): JSX.Element | string {
// OBSOLETE     if (ti[propName] === undefined) return '---'
// OBSOLETE     var resultString = genericGroupedAsJSONArrayKeepDups.singleLineString(propName, ti)
// OBSOLETE     // trim string - if it is too long, TruncatedFormat will barf (renders an extra ellipsis icon, looks gross)
// OBSOLETE     if (resultString.length > 1000) resultString = resultString.slice(0, 1000)
// OBSOLETE     return resultString
// OBSOLETE   },
// OBSOLETE   multiLineString(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): string {
// OBSOLETE     if (ti[propName] === undefined) return ''
// OBSOLETE     else {
// OBSOLETE       const counts = getUniquesAndCountsForGenericGroupedAsJSONArrayKeepDups(ti[propName])
// OBSOLETE       var items: string[] = Object.getOwnPropertyNames(counts.counts)   // NOT SORTING - may be useful to see them in same order as appear in children???  and anyway, ContentView has 
// OBSOLETE       if (cvMode === 'Sorted') items.sort()
// OBSOLETE       let result: string = ''
// OBSOLETE       if (includeCount && (counts.total > 1)) {
// OBSOLETE         result += `(${counts.total} total items`
// OBSOLETE         if (items.length > 1) result += `, ${items.length} unique)\n===============\n`
// OBSOLETE         else result += ')\n=================\n'
// OBSOLETE       }
// OBSOLETE       for (let i of items) {
// OBSOLETE         result += `${CVModeTransformers[cvMode](i)}\n`
// OBSOLETE         // for object-backed props, the strings are likely to be multiline themselves, so put a divider between items
// OBSOLETE         if (ti[propName+'Object'] !== undefined) result += '=========================\n'
// OBSOLETE       }
// OBSOLETE       return result.slice(0, -1) // remove trailing '\n'
// OBSOLETE     }
// OBSOLETE   },
// OBSOLETE   contentViewJSX(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode, size?: SizePropsPx): JSX.Element {
// OBSOLETE     if (ti[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
// OBSOLETE     //else return <div className='ttCellMultiLineJSX'>{genericGrouped.multiLineString(ti, propName, includeCount, cvMode)}</div>
// OBSOLETE     else return (
// OBSOLETE       <CodeMirrorView
// OBSOLETE         value={genericGroupedAsJSONArrayKeepDups.multiLineString(ti, propName, includeCount, cvMode)}
// OBSOLETE         mode={cvMode}
// OBSOLETE         initialFocus={'matchInput'}
// OBSOLETE         initialMatchPattern=''
// OBSOLETE         size={ size }
// OBSOLETE         editable={false}
// OBSOLETE       />
// OBSOLETE     )
// OBSOLETE   },
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE // for props where we aggregate multiple values as a list ('\n' delimited)
// OBSOLETE //   note:
// OBSOLETE //     does not create backing 'Object' props the way that genericGroupsAsArray does
// OBSOLETE //     empty lines
// OBSOLETE //        these will be assumed to reflect an underlying value of '' in the TII prop
// OBSOLETE //        so they will be included in counts and retained when grouping
// OBSOLETE //        ==> NEED TO BE CAREFUL WHEN CONSTRUCTING THESE VALUES - A TRAILING \n WILL RESULT IN A '' AFTER IT WHEN WE DO .split
// OBSOLETE //          IF THIS IS NOT WHAT IS INTENDED, THEN NEED TO STRIP OFF THE TRAILING \n
// OBSOLETE //          ==> so, when building using .join('\n'), we get the result we want, i.e., .split will get back to the original array
// OBSOLETE //          ==> however, when building using result += newItem + '\n', we need to strip the last \n after the build is done
// OBSOLETE //     handling of duplicates is as for genericGroupedAsArray
// OBSOLETE export function getUniquesAndCountsForGenericGroupedAsListKeepDups(s: string): { total: number, counts: { [index: string]: number } } {
// OBSOLETE   const items = s.split('\n')
// OBSOLETE   const counts = _.countBy(items)
// OBSOLETE   var nonEmptyCount = items.length
// OBSOLETE   // OBSOLETE - SEE ABOVE - WE NOW TREAT EMPTY ITEMS AS REAL VALUES OF ''     if (counts[''] !== undefined) {   // if source string includes any empty lines, and/or a trailing \n, 
// OBSOLETE   // OBSOLETE - SEE ABOVE - WE NOW TREAT EMPTY ITEMS AS REAL VALUES OF ''       nonEmptyCount -= counts['']         // the result of _.countBy will include a prop with a key of ''
// OBSOLETE   // OBSOLETE - SEE ABOVE - WE NOW TREAT EMPTY ITEMS AS REAL VALUES OF ''       delete counts['']               // we just delete the key (if there is no '' key, this operation still succeeds)
// OBSOLETE   // OBSOLETE - SEE ABOVE - WE NOW TREAT EMPTY ITEMS AS REAL VALUES OF ''     }                                 // also need to reduce total item count to not include the empties
// OBSOLETE   // OBSOLETE - SEE ABOVE - WE NOW TREAT EMPTY ITEMS AS REAL VALUES OF ''     delete counts['']   
// OBSOLETE   return {
// OBSOLETE     total: nonEmptyCount,
// OBSOLETE     counts: counts
// OBSOLETE   }
// OBSOLETE }
// OBSOLETE export const genericGroupedAsListKeepDups : TIPropFunctions = {
// OBSOLETE   convertOnLoad: generic.convertOnLoad,
// OBSOLETE   testMethod(propValue: string, trueIfEqual: boolean, regex: RegExp, ifChildTIITestResultsDisagree: boolean): boolean {
// OBSOLETE     const counts = getUniquesAndCountsForGenericGroupedAsListKeepDups(propValue)
// OBSOLETE     const items = Object.getOwnPropertyNames(counts.counts).sort()   // we sort here, but not for multiLineString, because ContentView has a 'sorted' mode
// OBSOLETE 
// OBSOLETE     // logic here is same as in TestOrGroup.result for testing over child TIs
// OBSOLETE     let anyTrue: boolean = false
// OBSOLETE     let allTrue: boolean = true
// OBSOLETE     for (let i of items) {
// OBSOLETE       if (trueIfEqual === regex.test(i)) anyTrue = true
// OBSOLETE       else allTrue = false
// OBSOLETE     }
// OBSOLETE     if (allTrue) return true
// OBSOLETE     else if (anyTrue) return ifChildTIITestResultsDisagree
// OBSOLETE     else return false
// OBSOLETE   },
// OBSOLETE   val: generic.val,
// OBSOLETE   active: generic.active,
// OBSOLETE   computeGroupProp(tig: TIG, children: TI[], propName: string) : string | number | undefined {
// OBSOLETE 
// OBSOLETE     // see notes in genericGroupedAsArray.computeGroupProp
// OBSOLETE 
// OBSOLETE     if (children.length === 0) return undefined
// OBSOLETE     const resultArray: string[] = []
// OBSOLETE 
// OBSOLETE     for (let c of children) {
// OBSOLETE       if (c[propName] === undefined) continue
// OBSOLETE 
// OBSOLETE       // OMIT CHILDREN IF THEY ARE HIDDEN
// OBSOLETE       if (c.testResults.hide === true) continue
// OBSOLETE 
// OBSOLETE       else resultArray.push(...c[propName].split('\n'))
// OBSOLETE     }
// OBSOLETE     if (resultArray.length === 0) return undefined
// OBSOLETE     // OBSOLETE COMMENT - SEE ABOVE join resultArray items with '\n', BUT DROP ANY THAT ARE '' (see notes above)
// OBSOLETE     var result: string = ''
// OBSOLETE     for (let r of resultArray) result += r + '\n'
// OBSOLETE     return result.slice(0, -1) // strip off trailing \n - see notes above
// OBSOLETE   },
// OBSOLETE 
// OBSOLETE   singleLineString(propName: string, ti: TI): string {
// OBSOLETE       if (ti[propName] === undefined) return '---'
// OBSOLETE       else {
// OBSOLETE         const counts = getUniquesAndCountsForGenericGroupedAsListKeepDups(ti[propName])
// OBSOLETE         const items = Object.getOwnPropertyNames(counts.counts).sort()   // we sort here, but not for multiLineString, because ContentView has a 'sorted' mode
// OBSOLETE 
// OBSOLETE         let result: string = ''
// OBSOLETE         if (counts.total > 1) {
// OBSOLETE           result += `(${counts.total}t`
// OBSOLETE           if (items.length > 1) result += `/${items.length}u) `
// OBSOLETE           else result += ') '
// OBSOLETE         }
// OBSOLETE         for (let i of items) result += `${i}, `
// OBSOLETE         return result.slice(0, -2) // remove trailing ', '
// OBSOLETE       }
// OBSOLETE   },
// OBSOLETE   singleLineJSX(propName: string, ti: TI): JSX.Element | string {
// OBSOLETE     if (ti[propName] === undefined) return '---'
// OBSOLETE     var resultString = genericGroupedAsListKeepDups.singleLineString(propName, ti)
// OBSOLETE     // trim string - if it is too long, TruncatedFormat will barf (renders an extra ellipsis icon, looks gross)
// OBSOLETE     if (resultString.length > 1000) resultString = resultString.slice(0, 1000)
// OBSOLETE     return resultString
// OBSOLETE   },
// OBSOLETE   multiLineString(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): string {
// OBSOLETE     if (ti[propName] === undefined) return ''
// OBSOLETE     else {
// OBSOLETE       const counts = getUniquesAndCountsForGenericGroupedAsListKeepDups(ti[propName])
// OBSOLETE       var items: string[] = Object.getOwnPropertyNames(counts.counts)    // NOT SORTING - may be useful to see them in same order as appear in children???  and anyway, ContentView has a 'sorted' mode
// OBSOLETE       if (cvMode === 'Sorted') items.sort()
// OBSOLETE       let result: string = ''
// OBSOLETE       if (includeCount && (counts.total > 1)) {
// OBSOLETE         result += `(${counts.total} total items`
// OBSOLETE         if (items.length > 1) result += `, ${items.length} unique)\n===============\n`
// OBSOLETE         else result += ')\n=================\n'
// OBSOLETE       }
// OBSOLETE       for (let i of items) {
// OBSOLETE         result += `${CVModeTransformers[cvMode](i)}\n`
// OBSOLETE         // for object-backed props, the strings are likely to be multiline themselves, so put a divider between items
// OBSOLETE         if (ti[propName+'Object'] !== undefined) result += '=========================\n'
// OBSOLETE       }
// OBSOLETE       return result.slice(0, -1) // remove trailing '\n'
// OBSOLETE     }
// OBSOLETE   },
// OBSOLETE   contentViewJSX(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode, size?: SizePropsPx): JSX.Element {
// OBSOLETE     if (ti[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
// OBSOLETE     //else return <div className='ttCellMultiLineJSX'>{genericGrouped.multiLineString(ti, propName, includeCount, cvMode)}</div>
// OBSOLETE     else return (
// OBSOLETE       <CodeMirrorView
// OBSOLETE         value={genericGroupedAsListKeepDups.multiLineString(ti, propName, includeCount, cvMode)}
// OBSOLETE         mode={cvMode}
// OBSOLETE         initialFocus={'matchInput'}
// OBSOLETE         initialMatchPattern=''
// OBSOLETE         size={ size }
// OBSOLETE         editable={false}
// OBSOLETE       />
// OBSOLETE     )
// OBSOLETE   },
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE 
// OBSOLETE // for props where we aggregate multiple values as a list ('\n' delimited)
// OBSOLETE //   note:
// OBSOLETE //     does not create backing 'Object' props the way that genericGroupsAsArray does
// OBSOLETE //     empty lines:
// OBSOLETE //        these will be assumed to reflect an underlying value of '' in the TII prop
// OBSOLETE //        so they will be included in counts and retained when grouping
// OBSOLETE //        ==> NEED TO BE CAREFUL WHEN CONSTRUCTING THESE VALUES - A TRAILING \n WILL RESULT IN A '' AFTER IT WHEN WE DO .split
// OBSOLETE //          IF THIS IS NOT WHAT IS INTENDED, THEN NEED TO STRIP OFF THE TRAILING \n
// OBSOLETE //          ==> so, when building using .join('\n'), we get the result we want, i.e., .split will get back to the original array
// OBSOLETE //          ==> however, when building using result += newItem + '\n', we need to strip the last \n after the build is done
// OBSOLETE //     handling of duplicates - duplicates are removed in the 'computeGroupProp' method
// OBSOLETE //       ==> methods that create TI prop values should be sure to remove duplicates as well
// OBSOLETE export const genericGroupedAsListNoDups : TIPropFunctions = {
// OBSOLETE   convertOnLoad: generic.convertOnLoad,
// OBSOLETE   testMethod: generic.testMethod,
// OBSOLETE   val: generic.val,
// OBSOLETE   active: generic.active,
// OBSOLETE   computeGroupProp(tig: TIG, children: TI[], propName: string) : string | number | undefined {
// OBSOLETE 
// OBSOLETE     // see notes in genericGroupedAsArray.computeGroupProp
// OBSOLETE 
// OBSOLETE     if (children.length === 0) return undefined
// OBSOLETE     const resultArray: string[] = []
// OBSOLETE 
// OBSOLETE     for (let c of children) {
// OBSOLETE       if (c[propName] === undefined) continue
// OBSOLETE 
// OBSOLETE       // OMIT CHILD IF HIDDEN
// OBSOLETE       if (c.testResults.hide) continue
// OBSOLETE 
// OBSOLETE       else resultArray.push(...c[propName].split('\n'))
// OBSOLETE     }
// OBSOLETE     if (resultArray.length === 0) return undefined
// OBSOLETE     const resultArrayDeDuped = Object.getOwnPropertyNames(_.countBy(resultArray))
// OBSOLETE     // OBSOLETE COMMENT - SEE ABOVE join resultArray items with '\n', BUT DROP ANY THAT ARE '' (see notes above)
// OBSOLETE     var result: string = ''
// OBSOLETE     for (let r of resultArrayDeDuped) result += r + '\n'
// OBSOLETE     return result.slice(0, -1) // strip off trailing \n - see notes above
// OBSOLETE   },
// OBSOLETE 
// OBSOLETE   singleLineString(propName: string, ti: TI): string {
// OBSOLETE       if (ti[propName] === undefined) return '---'
// OBSOLETE       else {
// OBSOLETE         const items = ti[propName].split('\n').sort()
// OBSOLETE         let result: string = ''
// OBSOLETE         if (items.length > 1) result += `(${items.length}u) `
// OBSOLETE         for (let i of items) result += `${i}, `
// OBSOLETE         return result.slice(0, -2) // remove trailing ', '
// OBSOLETE       }
// OBSOLETE   },
// OBSOLETE   singleLineJSX(propName: string, ti: TI): JSX.Element | string {
// OBSOLETE     if (ti[propName] === undefined) return '---'
// OBSOLETE     var resultString = genericGroupedAsListNoDups.singleLineString(propName, ti)
// OBSOLETE     // trim string - if it is too long, TruncatedFormat will barf (renders an extra ellipsis icon, looks gross)
// OBSOLETE     if (resultString.length > 1000) resultString = resultString.slice(0, 1000)
// OBSOLETE     return resultString
// OBSOLETE   },
// OBSOLETE   multiLineString(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode): string {
// OBSOLETE     if (ti[propName] === undefined) return ''
// OBSOLETE     else {
// OBSOLETE       var items: string[] = ti[propName].split('\n')
// OBSOLETE       if (cvMode === 'Sorted') items.sort()
// OBSOLETE       let result: string = ''
// OBSOLETE       if (includeCount && (items.length > 1)) result += `(${items.length} unique items)\n=================\n`
// OBSOLETE       for (let i of items) {
// OBSOLETE         result += `${CVModeTransformers[cvMode](i)}\n`
// OBSOLETE         // for object-backed props, the strings are likely to be multiline themselves, so put a divider between items
// OBSOLETE         if (ti[propName+'Object'] !== undefined) result += '=========================\n'
// OBSOLETE       }
// OBSOLETE       return result.slice(0, -1) // remove trailing '\n'
// OBSOLETE     }
// OBSOLETE   },
// OBSOLETE   contentViewJSX(ti: TI, propName: string, includeCount: boolean, cvMode: CVMode, size?: SizePropsPx): JSX.Element {
// OBSOLETE     if (ti[propName] === undefined) return <div className='ttCellMultiLineJSX'>---</div>
// OBSOLETE     //else return <div className='ttCellMultiLineJSX'>{genericGrouped.multiLineString(ti, propName, includeCount, cvMode)}</div>
// OBSOLETE     else return (
// OBSOLETE       <CodeMirrorView
// OBSOLETE         value={genericGroupedAsListNoDups.multiLineString(ti, propName, includeCount, cvMode)}
// OBSOLETE         mode={cvMode}
// OBSOLETE         initialFocus={'matchInput'}
// OBSOLETE         initialMatchPattern=''
// OBSOLETE         size={ size }
// OBSOLETE         editable={false}
// OBSOLETE       />
// OBSOLETE     )
// OBSOLETE   },
// OBSOLETE 
// OBSOLETE }
// OBSOLETE 
// OBSOLETE 


