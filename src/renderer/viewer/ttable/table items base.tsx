
import { observable, computed, makeObservable, action, observe, AnnotationsMap, reaction, Lambda, IArrayDidChange, IObjectDidChange, IValueDidChange, runInAction, comparer } from 'mobx'

import { KindsG, KindsI, Kinds, ITIBase } from '../common/commonAll'
import { TTable } from './TTable base Obj'

import { v4 as uuidv4 } from 'uuid'
import md5 from 'md5'
import {  } from '../common/configTypesUtility'
import { SetMDClass, SetClass, SetRaw, ConfigItemRaw, ItemRaw } from '../common/configTypesTypes'

const cl = console.log

var _ = require('lodash')

/*
  class hierarchy
    TIBase - has kind, basic tiInfo prop, parentTIG and parentApp

      TII - declares group='no', restricts kind to I kinds 
      TIG - declares group='yes', restricts kind to G kinds, declares children array, add-related methods

        TIHI - adds hierarchy-based props and methods to group TIs by common prop values, overrides tiInfo to show hierarchy levels
        TIHG - similar to TIHI, has 'add' method to add a new TIH to hierarchy based on its prop values

          CRI, CRG - extend TIHI/TIHG, add properties and restrict types specific to CRs

        OI, OG - extend TII/TIG, add properties and restrict types specific to object items
        (note: extends TI*, not TIH* - this class does allow hierarchy/nesting, but the grouping/hierarchy is determined by the structure of the object itself
        so we don't need the machinery of TIH* 

    Note: could have just specialized CR* from TI*, but created the intermediate
    TIH* classes anticipating that there will be other types of TI* in the future
*/

/*

DOCUMENT REQUIREMENTS FOR '_id' PROP
  EVERY TI WILL HAVE AN _id prop
  WE NAME IT '_id' SO THAT IT WILL ALSO BE THE DEFAULT MONGO DOCUMENT ID PROP 
  TIBase constructor will create one, using uuid
  _id does not have to be generated by uuid, but it must be GLOBALLY unique, since this is how we will
    store references to a TI (when an object reference to the actual TI does not do the job)
    (Globally means unique across all instances of my application, over all time - uuid is
      not absolutely guaranteed to be unique, but collisions are extremely improbable)
  TII.addedProps will include '_id' at initialization, because we always want to include 
    _id when exporting
  other code can replace the _id value, in particular,
    a)  if something is loaded, from mongo or elsewhere, that already has an _id prop
        the loaded _id can replace the one assigned at construction
    b) if a TI is created due to an 'undo' operation, it will have its _id assigned as the previous value by the undo-ing method

    
DOCUMENT MEANING/HANDLING OF PROPS IN uniquePropNames
  these are derived from crHierarchy for each CRI and CRG
  for a CRG, these are props that must be identical for all children
  for a CRI, these are props that will be identical with all siblings in the direct parent CRG (by the above rule)
  any of these props can be undefined, either because it was assigned the value undefined,
    or because the prop does not exist
  grouping code should treat undefined as a valid value, and group accordingly
  javascript treats two expressions that evaluate to undefined as ===, whether they
    came from a prop that was assigned undefined, or a prop that was never created

DOCUMENT REQUIREMENTS FOR COMPUTED GROUP PROPS FOR PROPS THAT ARE USED IN crHierarchy:
  if this prop lives directly on the crg, rather than being a function of the children, return it
  else 
    if no children, return undefined
    if children
        compute across children
        validate that props in uniquePropNames return a single value

DOCUMENT MEANING/INTERPRETATION OF AN EMPTY CRG
  NORMALLY A CRG WILL HAVE AT LEAST ONE CHILD - they originate when a CRI is loaded and CRG(s) are created to contain them
  WE CONSTRUCT THEM EMPTY, SO THAT THE FUNCTIONALLY CREATED COMPUTEDS WILL INITIALIZE PROPERLY
     BEFORE THEY ARE USED IN THE ADD PROCESS
  TYPICALLY A CRG WILL HAVE A CHILD ADDED TO IT IMMEDIATELY AFTER CONSTRUCTION,
  AN EMPTY CRG 
    WILL HAVE A kind
    SHOULD RETURN undefined FOR ALL COMPUTED PROP VALUES
    SHOULD RETURN true FOR matchOrCanOwn AS LONG AS THE KINDS MATCH
  GENERALLY, WE WILL ADD A CHILD TO A CRG IMMEDIATELY AFTER CREATION,
  I.E., WE WILL NOT HAVE EMPTY CRGS IN THE TREE

parentTTable and parentTIG
  A TI WILL ALWAYS HAVE A parentTTable, I.E., A ti CANNOT EXIST OUTSIDE THE CONTEXT OF A TTABLE
  (AT THIS WRITING, I DON'T HAVE ANY USE CASES FOR MOVING A TI BETWEEN TTABLES,
  SO THE TIG addDirectChild METHOD THROWS AN ERROR IF THE NEW CHILD'S PARENTTTABLE !== ITS OWN)

  ON THE OTHER HAND, A ti DOES NOT NECESSARILY NEED TO HAVE A parentTIG
  (FOR ONE REASON, THEY NEED BE CONSTRUCTED FIRST, BEFORE GETTING ASSIGNED TO A PARENTTIG, AT LEAST FOR HIERARCHICAL TIGS)


*/



export interface TIInfo2 {
  kind: string,
  childCount: number,
  infoShort: string[],  // to be shown in cell (concatenated into single line view)
  infoLong: string[],   // to be shown in ContentView (separated by newlines)
  exceptions: string[], // to be shown before infoShortLong,
                        // and highlighted (maybe red font)
                        // and propagated up to parents
}


export abstract class TIBase implements ITIBase {
  [index: string]: any
  _id: string = uuidv4().toString()   // see notes above on _id prop
  kind: Kinds

  // parent references
  //    direct parent
  //    TTable that owns
  // direct parent TIG can be undefined
  // undefined at construction
  parentTIG: TIG | undefined = undefined
  // get parentTIG assuming it is not undefined - throw error if it is undef
  get parentTIGdef(): TIG {
    if (this.parentTIG === undefined) throw new Error(`tried to access parentTIGdef but parentTIG is undefined`)
    else return this.parentTIG
  }
  parentTTable: TTable
  tableRow: number = -1  // will be assigned by TTable.visibleSortedExpandedMap
                       // value is -1 if not in the visible table (e.g., because parentTIG is collapsed)

  // values based on position in hierarchy
  get level(): number {
    if (this.kind === 'rootG') return 0
    if (this.parentTIG === undefined) return 0
    return (this.parentTIG.level + 1)
  }

  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE // base value for tiInfo - this will be over-ridden by some subclasses
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE get tiInfo(): string {
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE   let result: string = '' // = this.unsavedChanges ? '*' : ''
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE   // now we do this in CellContent if (this.level > 1) result += '   '.repeat(this.level-1) + 'â†³'
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE   result += this.kind
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE   if (this.group === 'yes') result += ` (${this.children.length})`
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE   return result
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE }

  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE get tiInfo2(): TIInfo2 {
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE   return {
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE     kind: this.kind,
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE     childCount: (this.group === 'no') ? 0 : this.children.count,
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE     infoShort: [],
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE     infoLong: [],
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE     exceptions: []
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE   }
  // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE }

  // test results for this TI - @computed so they are memo-ized
  get testResults(): { show: boolean, hide: boolean, highlight: boolean} {
    if (this.parentTTable === undefined) return { show: true, hide: false, highlight: false}
    else return {
      show:      this.parentTTable.showTests.result(this, true, true),
      hide:      this.parentTTable.hideTests.result(this, false, false),
      highlight: this.parentTTable.highlightTests.result(this, true, true),
    }
  }

  constructor(kind: Kinds, parentTTable: TTable) {
    this.kind = kind
    this.parentTTable = parentTTable

    makeObservable(this, {
      parentTIG: observable,
      level: computed({keepAlive: true}),
      // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE tiInfo: computed({keepAlive: true}),
      // NO LONGER ON BASE CLASS - SUBCLASSES MUST DECLARE, NOT OVERRIDE tiInfo2: computed({keepAlive: true}),
      testResults: computed({keepAlive: true}),
    })
  }



}

//================================================================================
//================================================================================
export type TI = TII | TIG

export abstract class TII extends TIBase implements ItemRaw {
  [index: string]: any
  readonly group: 'no' = 'no'
  kind: KindsI
  highlightLevelMatching: number = 0
  addedProps: string[] = ['_id']   // see notes above on _id prop 
  // OBSOLETE unsavedChanges: boolean = false
  // props currently only used for Config Items, but declared here in case we want to use editability, change tracking etc. for other kinds of TIs
  modified: boolean = true  // note: will be populated when items loaded from saved config set
                        // but still we declare it here for TI types other than ConfigI
  timestamp: number = Date.now()
  tempItem: boolean = false

  constructor(kind: KindsI, parentTTable: TTable) {
    super(kind, parentTTable)
    this.kind = kind
    makeObservable(this, {
      tableRow: observable,
      highlightLevelMatching: observable,
    })
  }
  
  // sets TableRow to -1 - this is a method to mirror TIG.resetTableRows
  resetTableRows() { this.tableRow = -1 }
  
  resetModified() { this.modified = false }

  populate(item: { [index: string]: any }) {
    // populate this
    for (let p in item) {
      this.addedProps.push(p)
      this[p] = item[p]
      // NOTE - reaction below ignores changes to _id and modified props, but we still want them to be
      // observable, so that GUI will update when they change

      // it seems we need to force the type of the options object in this case
      if (this.parentTTable.changeTrackingSetupEnabled === true) makeObservable(this, { [p]: observable } as AnnotationsMap<{[index: string]: any}, never>)
      // DON'T THINK I NEED TO MAKE PROPITEMS OBSERVABLE, AND ANYWAY THIS CALL DOES NOT WORK (FAILS WITH 'field not found' // if there is a related PropItems, make it observable too
      // DON'T THINK I NEED TO MAKE PROPITEMS OBSERVABLE, AND ANYWAY THIS CALL DOES NOT WORK (FAILS WITH 'field not found' if (item[p+'PropItems'] !== undefined)  makeObservable(this, { [p+'PropItems']: observable } as AnnotationsMap<{[index: string]: any}, never>)
    }
    // if changeTrackingSetupEnabled is true,
    // add reaction that will notify parentTTable on changes
    if (this.parentTTable.changeTrackingSetupEnabled) {
      reaction(
        ()=>{
          // DON'T REACT IF _id OR modified CHANGES
          const p = this.export()
          delete p['_id']
          delete p['modified']
          delete p['timestamp']
          return p
        },
        (props, prevProps, reaction) => {
          // don't do anything if this is a temp item
          // this is a hack-y solution - methods that update temp items use changeTrackingActive to prevent updates here
          // but it doesn't work in some cases (maybe because those methods are wrapped in runInAction??)
          if (this.tempItem === true) return

          const priorItemId = this._id
          const priorItemModified = this.modified
          const priorItemTimestamp = this.timestamp

          //cl(`configI reaction detected change, lastChangeWasUndo: ${this.lastChangeWasUndo}`)
          if (this.parentTTable.changeTrackingActive) {
            //cl(`TI observer handling prop change(s)`)
            this._id = uuidv4()
            this.modified = true
            this.timestamp = Date.now()

            // OBSOLETE - NOW COMPUTED const newSetMD = this.parentTTable.nonTempSetMD.generateUpdatedSetMDObj(this.parentTTable.root.children as unknown as ConfigItemRaw[], true) // calcSetMDFromSet(this.parentTTable.nonTempSetMD, this.parentTTable.root.children as unknown as ConfigItemRaw[], true)
            // OBSOLETE const newSetMD = {   // need to make a whole new object instance, not just a new value for id
            // OBSOLETE                     // otherwise setting newSetMD in the delta to the current setMD with one prop changed also changes the instance pointed to by priorSetMD
            // OBSOLETE   id: calcSetIdFromItems(this.parentTTable.root.children as unknown as ConfigItemRaw[]),
            // OBSOLETE   timestamp: Date.now(),
            // OBSOLETE   notes: this.parentTTable.nonTempSetMD.notes
            // OBSOLETE }
            //cl(`reaction adding tiDelta`)
            this.parentTTable.onTIChangeDetected(
              this,
              {
                priorItemId: priorItemId,
                newItemId: this._id,
                priorTimestamp: priorItemTimestamp,
                priorModified: priorItemModified,
                currentFocusElement: document.activeElement,
                currentTableSelection: _.clone(this.parentTTable.selection),
                type: 'propChange',
                priorProps: prevProps,
                newProps: props
              }
            )
            // OBSOLETE - NOW COMPUTED this.parentTTable.nonTempSetMD = newSetMD
          }
        },
        { equals: comparer.structural }  // data function always returns a new object reference
                                        // only want reaction to run if values in the object have changed
      )
    }
  }

  export(): { [index: string]: any } {
    const result: { [index: string]: any } = {}
    for (let p of this.addedProps) {
      result[p] = this[p]
    }
    return result
  }
  

  // see notes on findTI method in TIG below
  findTI(_id: string): { parent: TIG | undefined, index: number } | undefined {
    // if _id matches this
    if (_id === this._id) {
      if (this.parentTIG === undefined) return { parent: undefined, index: 0 }
      else return {
        parent: this.parentTIG,
        index: this.parentTIG.children.findIndex(i => (i._id === _id))
      }
    }
    else return undefined
  }

}




export class SetMDClassObservableComputed extends SetMDClass {
  constructor(parentSet: SetClass, notes: string, lastIdSaved: string) {
    super(parentSet, notes, lastIdSaved, true)
    makeObservable(this, {
      id: computed({keepAlive: true}),
      timestamp: computed({keepAlive: true}),
      modified: computed({keepAlive: true}),
      notes: observable,
      lastIdSaved: observable
    })
  }
}


export class TIG extends TIBase implements SetClass {
  [index: string]: any
  // group property will be used as "discriminant" property per typescript "discriminated unions"
  readonly group: 'yes' = 'yes'
  kind: KindsG
  get highlightLevelMatching(): number {
    let result = 0
    for (let c of this.children) if (c.highlightLevelMatching > result) result = c.highlightLevelMatching
    return result
  }
  expanded: boolean = false
  md: SetMDClassObservableComputed  // initialize in constructor, so that this.children is available
  // implement ItemRaw props (even though these are not used anywhwere - we use the md props instead)
  timestamp: number = -1
  modified: boolean = true
  tempItem: boolean = false

  children: TI[] = []
  timestampLastArrayMod: number = 0

  childrenChangeObserver: Lambda | undefined

  constructor(kind: KindsG, parentTTable: TTable) {
    super(kind, parentTTable)
    this.kind = kind

    makeObservable(this, {
      tableRow: observable,
      highlightLevelMatching: computed({keepAlive: true}),
      resetHighlightLevelMatching: action.bound,
      expanded: observable,
      children: observable,
      timestampLastArrayMod: observable,
      addDirectChild: action.bound,
    })

    this.md = new SetMDClassObservableComputed(this, 'at TIG construction', 'at TIG construction')

    if (parentTTable.changeTrackingSetupEnabled) {
      // observe changes to value of children itself (i.e., if a whole new array is assigned to this.children)
      observe(this, 'children', (change) => {
        // dispose of prior childrenChangeObserver - in case the prior value of 
        // children is not garbage-disposed because it is still alive somewhere else
        // in the application (e.g., in the tiDelta's stack)
        if (this.childrenChangeObserver !== undefined) this.childrenChangeObserver()
        // ... and establish observer on new array in this.children
        if (this.parentTTable.changeTrackingSetupEnabled) {
          this.childrenChangeObserver = observe(this.children, change => {
            this.handleChildrenSpliceChange(change as unknown as IArrayDidChange<this['children']>)
          })
        }
        this.handleChildrenValueChange(change)
      })
      // observe changes within this.children
      // store the disposer so it can be disposed when this.children is replaced
      this.childrenChangeObserver = observe(this.children, change => {
        this.handleChildrenSpliceChange(change as unknown as IArrayDidChange<this['children']>)
      })
    }
  }

  export(): { [index: string]: any }[] {
    return this.children.map(c => c.export())
  }

  // calls SetClass utility method  
  exportSetRaw(tempNonTemp: 'temp' | 'nonTemp' | 'both'): SetRaw {
    return SetClass.exportSetRaw(this, tempNonTemp, (i: Object) =>{const ic: TII = i as TII; return ic.export() as ItemRaw})
  }

  resetModified() {
    SetClass.resetModified(this)
  }


  // sets TableRow on all children to -1 (recurses down tree)
  resetTableRows() {
    this.tableRow = -1
    for (let c of this.children) c.resetTableRows()
  }
  


  resetHighlightLevelMatching() {
    for (let c of this.children) {
      if (c instanceof TII) c.highlightLevelMatching = 0
      else c.resetHighlightLevelMatching()
    }
  }

  handleChildrenValueChange(change: IValueDidChange<this['children']>) {
    //cl(`handleChildrenValueChange called: change is:`)
    //cl(change)
    runInAction(()=>{
      const prior_id = this._id
      const prior_tsLastArrayMod = this.timestampLastArrayMod
      this.timestampLastArrayMod = Date.now()
      if (this.parentTTable.changeTrackingActive) {
        this.parentTTable.onTIChangeDetected(
          this,
          {
            priorTimestampLastArrayMod: prior_tsLastArrayMod,
            priorItemId: prior_id,
            newItemId: this._id,
            currentFocusElement: document.activeElement,
            currentTableSelection: _.clone(this.parentTTable.selection),
            type: 'arrayChangeReplace',
            priorChildren: (change.oldValue as TI[]).map(i => i.export()),
            newChildren: (change.newValue as TI[]).map(i => i.export()),
          }
        )
      }

    })
  }

  handleChildrenSpliceChange(change: IArrayDidChange<this['children']>) {
    //cl(`handleChildrenSpliceChange called: change is:`)
    //cl(change)
    runInAction(()=>{
      if (this.parentTTable.changeTrackingActive) {
        const prior_id = this._id
        const prior_tsLastArrayMod = this.timestampLastArrayMod
        this.timestampLastArrayMod = Date.now()
        if (change.type === 'splice') {
          this.parentTTable.onTIChangeDetected(
            this,
            {
              priorTimestampLastArrayMod: prior_tsLastArrayMod,
              priorItemId: prior_id,
              newItemId: this._id,
              currentFocusElement: document.activeElement,
              currentTableSelection: _.clone(this.parentTTable.selection),
              type: 'arrayChangeSplice',
              index: change.index,
              added: change.added.map(i => (i as unknown as TI).export()),
              addedCount: change.addedCount,
              removed: change.removed.map(i => (i as unknown as TI).export()),
              removedCount: change.removedCount,
            }
          )
        }
      }

    })
  }


  // convenience method to ensure that new child has parentTIG, parenttTTable set
  // DOES NOT VALIDATE that this can own newChild based on values of properties
  // note this is called 'addDirectChild' to be more distinct from other 'add*' methods
  // if 'position' provided, insert or replace in children at that index
  // (replace or insert depending on third argument)
  // (insert is the default if third argument missing)
  // VALIDATES THAT position is <= children.length
  addDirectChild(newchild: TI, position?: number, replaceOrInsert?: 'replace' | 'insert') {
    // DON'T NEED TO DO THIS HERE, IT WILL HAPPEN IN handleChildrenSpliceChange ABOVE - this.timestampLastArrayMod = Date.now()
    if (newchild.parentTTable !== this.parentTTable) throw new Error(`TRIED TO addDirectChild BUT newchild.parentTTable !== this.parentTTable`)
    if (position !== undefined) {
      if ((position < 0) || (position > this.children.length+1))  throw new Error(`TRIED TO addDirectChild at position ${position}, which is out of bounds`)
    }
    newchild.parentTIG = this
    newchild.parentTTable = this.parentTTable
    if (position === undefined) this.children.push(newchild)
    else if ((replaceOrInsert === undefined) || (replaceOrInsert === 'insert')) this.children.splice(position, 0, newchild)
    else this.children[position] = newchild

  }


  // finds TI that has _id, which may be this or any of its direct or indirect children
  // return result is a ref to its parent, and an index into the parent's children
  // if no match found, return undefined
  // if _id matches this, but this has no parent, return parent: undefined in return object
  findTI(_id: string): { parent: TIG | undefined, index: number } | undefined {
    // if _id matches this
    if (_id === this._id) {
      if (this.parentTIG === undefined) return { parent: undefined, index: 0 }
      else return {
        parent: this.parentTIG,
        index: this.parentTIG.children.findIndex(i => (i._id === _id))
      }
    }
    // else search through children
    for (let i:  number = 0; i < this.children.length; i++) {
      if (this.children[i]._id === _id) return { parent: this, index: i }
      let childResult = this.children[i].findTI(_id)
      if (childResult !== undefined) return childResult
    }

    // if we got this far, no match found
    return undefined

  }

  getTIIs(): TII[] {
    let result: TII[] = []

    for (let c of this.children) {
      if (c instanceof TIG) result.push(...c.getTIIs())
      else result.push(c)
    }
    return result
  }
/*
  // returns true if TI exists somewhere in this.children (searches through tree)
  doesTIExistInChildren(ti: TI): boolean {
    for (let c of this.children) {
      if (c === ti) return true
      else if (c instanceof TIG) {
        if (c.doesTIExistInChildren(ti)) return true
      }
    }
    return false
  }

  // returns true if THIS tig, or any child, matches argument
  doesTIGExist(tig: TIG): boolean {
    if (tig === this) return true
    else for (let c of this.children) {
      if (c instanceof TIG) {
        if (c.doesTIGExist(tig)) return true
      }
    }
    return false
  }
*/
}

